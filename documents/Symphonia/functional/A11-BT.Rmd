---
title: "A11: BT & Environment"
date: '`r Sys.Date()`'
output:
  bookdown::html_document2:
    number_sections: false
    toc: true
    toc_float: yes
  bookdown::word_document2: default
  github_document: default
  bookdown::pdf_document2:
    includes:
      before_body: ./template/doc_prefix.tex
      in_header: ./template/preamble.tex
    number_sections: false
    toc: false
    keep_tex: true
linestretch: 1.5
csl: /home/sylvain/Documents/Bibliography/csl/mee.csl
bibliography: /home/sylvain/Documents/Bibliography/library.bib
link-citations: yes
---

```{r setup, include=FALSE}
rm(list = ls()) ; invisible(gc()) ; set.seed(42)
library(knitr)
library(parallel)
library(tidyverse)
library(ggfortify)
library(raster)
library(rstan)
library(bayesplot)
theme_set(bayesplot::theme_default())
opts_chunk$set(
  echo = F, message = F, warning = F, fig.height = 6, fig.width = 6,
  cache = T, cache.lazy = F)
options(mc.cores = parallel::detectCores())
rstan_options(auto_write = T)
path <- "~/Documents/BIOGECO/PhD/data/Paracou/"
crs <- '+proj=longlat +datum=NAD83 +no_defs +ellps=GRS80 +towgs84=0,0,0' # global crs definition
```

```{r traits}
traits <- googlesheets::gs_title("Measures") %>% 
  googlesheets::gs_read("AllTraits") %>% 
  mutate(SLA = as.numeric(SLA), LDMC = as.numeric(LDMC))
```

```{r trees}
trees <- src_sqlite(file.path(path, "trees/Paracou.sqlite")) %>% 
  tbl("Paracou") %>% 
  filter(idTree %in% traits$idTree) %>% 
  collect() %>% 
  mutate(DBH = CircCorr*pi)
```

```{r env}
# env <- trees %>%
#   dplyr::select(idTree, Xutm, Yutm) %>%
#   unique()
# coordinates(env) <- ~Xutm + Yutm
# proj4string(env) <- '+proj=utm +zone=22 +datum=WGS84 +units=m +no_defs +ellps=WGS84 +towgs84=0,0,0'
# env <- spTransform(env, CRSobj = crs)
# topo <- stack(
#   raster(file.path(path, "topography", "DEM_1m_2015.tif")),
#   raster(file.path(path, "topography", "RelativeElevation_1m.tif")),
#   raster(file.path(path, "topography", "slope_1m.tif")),
#   raster(file.path(path, "topography", "curvature_1m.tif")),
#   raster(file.path(path, "topography", "aspect_1m.tif")),
#   raster(file.path(path, "topography", "TRI_1m.tif")),
#   raster(file.path(path, "topography", "TWI_1m.tif"))
# )
# names(topo) <- c("DEM", "RelativeElevation", "Slope", "Curvature",
#                  "Aspect", "TRI", "TWI")
# topo <- projectRaster(topo, crs = crs)
# env <- data.frame(cbind(env@data, raster::extract(topo, env)))
# rm(topo)
# save(env, file = "./functional_save/env.Rdata")
load("./functional_save/env.Rdata")
```

```{r data}
data <- traits %>%
  mutate(Dawkins = as.numeric(substr(Dawkins, 1,1))) %>% 
  left_join(dplyr::filter(trees, CensusYear == 2015)) %>%
  left_join(env) %>% 
  dplyr::filter(!is.na(brBT)) %>% 
  group_by(Bark, idTree) %>% 
  summarise_if(is.numeric, mean, na.rm =T) %>% 
  ungroup() %>% 
  mutate(DBH = DBH/max(DBH)) %>% 
  mutate(DEM = DEM/max(DEM)) %>% 
  mutate(TWI = TWI/max(TWI))
```

# Introduction

First model for BT variation in relation to environment.

# BT - DBH

## Relation

```{r BTDBH}
data %>% 
  ggplot(aes(DBH, brBT, col = Bark, group = NA)) +
  geom_point() +
  geom_smooth()
```

## Linear model

We will used a linear equation for DBH effect on BT.

$$BT \sim \mathcal{N} (\alpha + \beta* dbh, \sigma) $$

```{stan MdbhLinear, output.var="MdbhLinear", echo=T, eval=F}
  data {
    int N ; // # obs
    real BT[N] ;
    real DBH[N] ;
  }
  parameters {
    real<lower=0> alpha ;
    real<lower=0> beta ;
    real<lower=0> sigma ;
  }
  model {
    for(n in 1:N)
      BT[n] ~ normal(alpha + beta*DBH[n], sigma) ;
  }
  generated quantities {
    real BTpred[N] ;
    for(n in 1:N)
      BTpred[n] = alpha + beta*DBH[n] ;
  }
```

```{r fitMdbhLinear}
# fit <- sampling(MdbhLinear, chains = 2,
#                 data = list(N = nrow(data),
#                             BT = data$brBT,
#                             DBH = data$DBH))
# save(fit, file = "./functional_save/ModelbrBTdbhLinear.Rdata")
load("./functional_save/ModelbrBTdbhLinear.Rdata")
pars <- c("alpha", "beta", "sigma")
broom::tidyMCMC(fit, pars = c(pars, "lp__"), droppars = NULL, rhat = T) %>% 
  kable(caption = "Summary table of the model dbh only")
```

```{r CdbhLinear, fig.cap="Model parameters posterior for model dbh only."}
mcmc_intervals(as.array(fit), pars = pars)
```

```{r TdbhLinear, fig.cap="Markov chains trace plot after warmup for model dbh only"}
mcmc_trace(as.array(fit), pars = c(pars, "lp__"),
           facet_args = list(labeller = label_parsed))
```

```{r 2dbhLinear, fig.cap="Markov chains pairs plot after warmup for model dbh only"}
mcmc_pairs(as.array(fit), pars = c(pars, "lp__"))
```

```{r YdbhLinear, fig.cap="Predictions for model dbh only"}
cbind(
  data,
  pred = apply(as.matrix(fit, pars = "BTpred"), 2, mean),
  t(apply(as.matrix(fit, pars = "BTpred"), 2, quantile, probs = c(0.05, 0.95)))
) %>% 
  ggplot(aes(x = DBH)) +
  geom_point(aes(y = brBT)) +
  geom_line(aes(y = pred), col = "red") +
  geom_ribbon(aes(ymin = `5%`, ymax = `95%`), color = 'red', alpha = 0.2) +
  geom_line(aes(y = `5%`), col = "red", alpha = 1, size = 0.5, linetype = "dashed") +
  geom_line(aes(y = `95%`), col = "red", alpha = 1, size = 0.5, linetype = "dashed")
```

## Michealis Menten model

We will used an inverted Michealis Menten equation for DBH effect on SLA.

$$BT \sim \mathcal{N} (\frac{\alpha * dbh}{dbh + \beta}, \sigma) $$

```{stan Mdbh, output.var="Mdbh", echo=T, eval=F}
  data {
    int N ; // # obs
    real BT[N] ;
    real DBH[N] ;
  }
  parameters {
    real<lower=0> alpha ;
    real<lower=0> beta ;
    real<lower=0> sigma ;
  }
  model {
    for(n in 1:N)
      BT[n] ~ normal((alpha*DBH[n])/(DBH[n] + beta), sigma) ;
  }
  generated quantities {
    real BTpred[N] ;
    for(n in 1:N)
      BTpred[n] = (alpha*DBH[n])/(DBH[n] + beta) ;
  }
```

```{r fitMdbh}
# fit <- sampling(Mdbh, chains = 2,
#                 data = list(N = nrow(data),
#                             BT = data$brBT,
#                             DBH = data$DBH))
# save(fit, file = "./functional_save/ModelbrBTdbh.Rdata")
load("./functional_save/ModelbrBTdbh.Rdata")
pars <- c("alpha", "beta", "sigma")
broom::tidyMCMC(fit, pars = c(pars, "lp__"), droppars = NULL, rhat = T) %>% 
  kable(caption = "Summary table of the model dbh only")
```

```{r Cdbh, fig.cap="Model parameters posterior for model dbh only."}
mcmc_intervals(as.array(fit), pars = pars)
```

```{r Tdbh, fig.cap="Markov chains trace plot after warmup for model dbh only"}
mcmc_trace(as.array(fit), pars = c(pars, "lp__"),
           facet_args = list(labeller = label_parsed))
```

```{r 2dbh, fig.cap="Markov chains pairs plot after warmup for model dbh only"}
mcmc_pairs(as.array(fit), pars = c(pars, "lp__"))
```

```{r Ydbh, fig.cap="Predictions for model dbh only"}
cbind(
  data,
  pred = apply(as.matrix(fit, pars = "BTpred"), 2, mean),
  t(apply(as.matrix(fit, pars = "BTpred"), 2, quantile, probs = c(0.05, 0.95)))
) %>% 
  ggplot(aes(x = DBH)) +
  geom_point(aes(y = brBT)) +
  geom_line(aes(y = pred), col = "red") +
  geom_ribbon(aes(ymin = `5%`, ymax = `95%`), color = 'red', alpha = 0.2) +
  geom_line(aes(y = `5%`), col = "red", alpha = 1, size = 0.5, linetype = "dashed") +
  geom_line(aes(y = `95%`), col = "red", alpha = 1, size = 0.5, linetype = "dashed")
```

In conclusion the likelihood is better for the Michaelis Menten form that we will use in following models, besides both model does not seems really good, surely because DBH must not affect much branc bark density.

# BT - TWI

## Relation

```{r BTTWI}
data %>% 
  ggplot(aes(TWI, brBT, size = DBH, aes = DBH,
             col = Bark, group = NA)) +
  geom_point() +
  geom_smooth()
```

## Linear model

We will used a linear equation for TWI effect on BT

$$BT \sim \mathcal{N} (\alpha + \beta* TWI, \sigma) $$

```{stan MTWI, output.var="MTWI", echo=T, eval=F}
  data {
    int N ; // # obs
    real BT[N] ;
    real TWI[N] ;
  }
  parameters {
    real alpha ;
    real beta ;
    real<lower=0> sigma ;
  }
  model {
    for(n in 1:N)
      BT[n] ~ normal(alpha + beta*TWI[n], sigma) ;
  }
  generated quantities {
    real BTpred[N] ;
    for(n in 1:N)
      BTpred[n] = alpha + beta*TWI[n] ;
  }
```

```{r fitMTWILinear}
# fit <- sampling(MTWI, chains = 2,
#                 data = list(N = nrow(data),
#                             BT = data$brBT,
#                             TWI = data$TWI))
# save(fit, file = "./functional_save/ModelbrBTTWI.Rdata")
load("./functional_save/ModelbrBTTWI.Rdata")
pars <- c("alpha", "beta", "sigma")
broom::tidyMCMC(fit, pars = c(pars, "lp__"), droppars = NULL, rhat = T) %>% 
  kable(caption = "Summary table of the model TWI only")
```

```{r CTWILinear, fig.cap="Model parameters posterior for model TWI only."}
mcmc_intervals(as.array(fit), pars = pars)
```

```{r TTWILinear, fig.cap="Markov chains trace plot after warmup for model TWI only"}
mcmc_trace(as.array(fit), pars = c(pars, "lp__"),
           facet_args = list(labeller = label_parsed))
```

```{r 2TWILinear, fig.cap="Markov chains pairs plot after warmup for model TWI only"}
mcmc_pairs(as.array(fit), pars = c(pars, "lp__"))
```

```{r YTWILinear, fig.cap="Predictions for model TWI only"}
cbind(
  data,
  pred = apply(as.matrix(fit, pars = "BTpred"), 2, mean),
  t(apply(as.matrix(fit, pars = "BTpred"), 2, quantile, probs = c(0.05, 0.95)))
) %>% 
  ggplot(aes(x = TWI)) +
  geom_point(aes(y = brBT)) +
  geom_line(aes(y = pred), col = "red") +
  geom_ribbon(aes(ymin = `5%`, ymax = `95%`), color = 'red', alpha = 0.2) +
  geom_line(aes(y = `5%`), col = "red", alpha = 1, size = 0.5, linetype = "dashed") +
  geom_line(aes(y = `95%`), col = "red", alpha = 1, size = 0.5, linetype = "dashed")
```

Topographic wetness index as a slightly significantl positive effect on BT.

# BT - Elevation

## Relation

```{r BTElevation}
data %>% 
  ggplot(aes(DEM, brBT, size = DBH, aes = DBH,
             col = Bark, group = NA)) +
  geom_point() +
  geom_smooth()
```

## Linear model

We will used a linear equation for elevation effect on BT

$$BT \sim \mathcal{N} (\alpha + \beta* Elevation, \sigma) $$

```{stan MElevation, output.var="MElevation", echo=T, eval=F}
  data {
    int N ; // # obs
    real BT[N] ;
    real Elevation[N] ;
  }
  parameters {
    real alpha ;
    real beta ;
    real<lower=0> sigma ;
  }
  model {
    for(n in 1:N)
      BT[n] ~ normal(alpha + beta*Elevation[n], sigma) ;
  }
  generated quantities {
    real BTpred[N] ;
    for(n in 1:N)
      BTpred[n] = alpha + beta*Elevation[n] ;
  }
```

```{r fitMElevation}
# fit <- sampling(MElevation, chains = 2,
#                 data = list(N = nrow(data),
#                             BT = data$brBT,
#                             Elevation = data$DEM))
# save(fit, file = "./functional_save/ModelbrBTElevation.Rdata")
load("./functional_save/ModelbrBTElevation.Rdata")
pars <- c("alpha", "beta", "sigma")
broom::tidyMCMC(fit, pars = c(pars, "lp__"), droppars = NULL, rhat = T) %>% 
  kable(caption = "Summary table of the model Elevation only")
```

```{r CElevationLinear, fig.cap="Model parameters posterior for model Elevation only."}
mcmc_intervals(as.array(fit), pars = pars)
```

```{r TElevationLinear, fig.cap="Markov chains trace plot after warmup for model Elevation only"}
mcmc_trace(as.array(fit), pars = c(pars, "lp__"),
           facet_args = list(labeller = label_parsed))
```

```{r 2ElevationLinear, fig.cap="Markov chains pairs plot after warmup for model Elevation only"}
mcmc_pairs(as.array(fit), pars = c(pars, "lp__"))
```

```{r YElevationLinear, fig.cap="Predictions for model Elevation only"}
cbind(
  data,
  pred = apply(as.matrix(fit, pars = "BTpred"), 2, mean),
  t(apply(as.matrix(fit, pars = "BTpred"), 2, quantile, probs = c(0.05, 0.95)))
) %>% 
  ggplot(aes(x = DEM)) +
  geom_point(aes(y = brBT)) +
  geom_line(aes(y = pred), col = "red") +
  geom_ribbon(aes(ymin = `5%`, ymax = `95%`), color = 'red', alpha = 0.2) +
  geom_line(aes(y = `5%`), col = "red", alpha = 1, size = 0.5, linetype = "dashed") +
  geom_line(aes(y = `95%`), col = "red", alpha = 1, size = 0.5, linetype = "dashed")
```

Elevation is strongly correlated to TWI and has a smaller likelihood than TWI, so we should only keep TWI as they give the same information.

# BT - Competition

```{r dataCompetition}
# cl <- makeCluster(4)
# clusterExport(cl, list("data", "path"))
# Competition <- clusterMap(cl,
#   function(id, plot, x, y){
#   library(dplyr)
#   src_sqlite(file.path(path, "trees/Paracou.sqlite")) %>%
#     tbl("Paracou") %>%
#     filter(CensusYear == 2005) %>%
#     filter(Plot == plot) %>% 
#     filter(idTree != id) %>% 
#     mutate(DBH = CircCorr*pi) %>%
#     mutate(dij = sqrt((x - Xutm)^2+(y - Yutm)^2)) %>%
#     filter(dij < 20) %>%
#     mutate(idTreej = idTree) %>%
#     mutate(idTreei = id) %>%
#     dplyr::select(idTreei, idTreej, DBH, dij) %>%
#     collect()},
#   id = data$idTree,
#   plot = data$Plot,
#   x = data$Xutm,
#   y = data$Yutm,
#   SIMPLIFY = F)
# stopCluster(cl)
# rm(cl)
# Competition <- bind_rows(Competition)
# Competition <- Competition %>% 
#   mutate(dij = ifelse(dij < 0.4, 0.4, dij)) # measure precision error troubling NCI fit 
# save(Competition, file = "./functional_save/CompetitionMatrix.Rdata")
load("./functional_save/CompetitionMatrix.Rdata")
```

## Relation

```{r BTCompetition}
Competition %>% 
  group_by(idTreei) %>% 
  summarise(NCI = sum(DBH*exp(-dij))) %>% 
  left_join(data, by = c("idTreei" = "idTree")) %>% 
  ggplot(aes(NCI, BT, size = DBH, aes = DBH,
             col = Bark, group = NA)) +
  geom_point() +
  geom_smooth()
```

## Competition model

$$BT_i \sim \mathcal{N} (\alpha + \beta* \sum _{j<20m} DBH_j^{\beta_{NCI}} * e^{-\alpha_{NCI}*d_{i,j}} , \sigma) $$

```{stan Mcomp, output.var="Mcomp", echo=T, eval=F}
  data {
    int N ; // # obs
    int J ; // # neighbours
    real BT[N] ;
    real DBH[J] ;
    real dij[J] ;
    int individual[J] ;
  }
  parameters {
    real alpha ;
    real beta ;
    real<lower=0, upper=1> alpha_NCI ;
    real<lower=0, upper=3> beta_NCI ;
    real<lower=0> sigma ;
  }
  transformed parameters {
    real NCI[N] ;
    for(n in 1:N)
      NCI[n] = 0 ;
    for(j in 1:J)
      NCI[individual[j]] = NCI[individual[j]] + DBH[j]^beta_NCI*exp(-alpha_NCI*dij[j]) ;
  }
  model {
    for(n in 1:N)
      BT[n] ~ normal(alpha + beta*NCI[n], sigma) ;
  }
  generated quantities {
    real BTpred[N] ;
    for(n in 1:N)
      BTpred[n] = alpha + beta*NCI[n] ;
  }
```

```{r fitMcomp}
# fit <- sampling(Mcomp, chains = 2,
#                 data = list(N = nrow(arrange(data, idTree)),
#                             J = nrow(arrange(Competition, idTreei)),
#                             BT = arrange(data, idTree)$BT,
#                             DBH = arrange(Competition, idTreei)$DBH,
#                             dij = arrange(Competition, idTreei)$dij,
#                             individual = as.numeric(as.factor(arrange(Competition, idTreei)$idTreei))))
# save(fit, file = "./functional_save/ModelBTCompetition.Rdata")
load("./functional_save/ModelBTCompetition.Rdata")
pars <- c("alpha", "beta", "alpha_NCI", "beta_NCI", "sigma")
alpha <- broom::tidyMCMC(fit, pars = "alpha_NCI")$estimate
beta <- broom::tidyMCMC(fit, pars = "beta_NCI")$estimate
broom::tidyMCMC(fit, pars = c(pars, "lp__"), droppars = NULL, rhat = T) %>% 
  kable(caption = "Summary table of the model competition only")
```

```{r Ccomp, fig.cap="Model parameters posterior for model competition only."}
mcmc_intervals(as.array(fit), pars = pars)
```

```{r Tcomp, fig.cap="Markov chains trace plot after warmup for model competition only"}
mcmc_trace(as.array(fit), pars = c(pars, "lp__"),
           facet_args = list(labeller = label_parsed))
```

```{r 2comp, fig.cap="Markov chains pairs plot after warmup for model competition only"}
mcmc_pairs(as.array(fit), pars = c(pars, "lp__"))
```

```{r Ycomp, fig.cap="Predictions for model competition only"}
cbind(
  Competition %>% 
    group_by(idTreei) %>% 
    summarise(NCI = sum(DBH^beta*exp(-alpha*dij))) %>% 
    left_join(data, by = c("idTreei" = "idTree")),
  pred = apply(as.matrix(fit, pars = "BTpred"), 2, mean),
  t(apply(as.matrix(fit, pars = "BTpred"), 2, quantile, probs = c(0.05, 0.95)))
) %>% 
  ggplot(aes(x = NCI)) +
  geom_point(aes(y = BT, size = DBH)) +
  geom_text(aes(y = BT, label = idTreei)) +
  geom_line(aes(y = pred), col = "red") +
  geom_ribbon(aes(ymin = `5%`, ymax = `95%`), color = 'red', alpha = 0.2) +
  geom_line(aes(y = `5%`), col = "red", alpha = 1, size = 0.5, linetype = "dashed") +
  geom_line(aes(y = `95%`), col = "red", alpha = 1, size = 0.5, linetype = "dashed")
```


# BT - Gaps

```{r dataGaps}
# gaps <- shapefile(file.path(path, "topography", "Gaps", "gaps4.shp"))
# crs(gaps) <- crs(raster(file.path(path, "biotic", "MNC_ParacouAvril2009_1m.tif")))
# gaps <- spTransform(gaps, '+proj=utm +zone=22 +datum=WGS84 +units=m +no_defs +ellps=WGS84 +towgs84=0,0,0')
# cl <- makeCluster(4)
# clusterExport(cl, list("data", "gaps"))
# Gaps <- clusterMap(cl,
#   function(id,  x, y){
#     d <- 50
#     gaps_sel <- raster::crop(rgeos::gBuffer(gaps, byid=TRUE, width=0), 
#                              raster::extent(matrix(c(x-d, y-d, x+d, y+d), nrow=2)))
#     tree <- data.frame(x = x, y = y)
#     sp::coordinates(tree) <- ~x+y
#     raster::crs(tree) <-  '+proj=utm +zone=22 +datum=WGS84 +units=m +no_defs +ellps=WGS84 +towgs84=0,0,0'
#     if(!is.null(gaps_sel))
#       data.frame(idTree = id,
#                  idGap = gaps_sel$fid,
#                  Area = raster::area(gaps_sel),
#                  Distance = rgeos::gDistance(tree, gaps_sel, byid = T)[,1])
#     },
#   id = data$idTree,
#   x = data$Xutm,
#   y = data$Yutm,
#   SIMPLIFY = F)
# stopCluster(cl)
# rm(cl)
# Gaps <- bind_rows(Gaps)
# Gaps <- Gaps %>% 
#   filter(Area < 500)
# Gaps <- Gaps %>% 
#   full_join(dplyr::select(data, idTree)) %>% 
#   mutate(Area = ifelse(is.na(Area), 0, Area)) %>% 
#   mutate(Distance = ifelse(is.na(Distance), 100, Distance))
# save(Gaps, file = "./functional_save/GapsMatrix.Rdata")
load("./functional_save/GapsMatrix.Rdata")
```


## Relation

```{r BTGaps}
Gaps %>% 
  filter(Area < 500) %>%
  mutate(Area = Area/max(Area)) %>% 
  mutate(Distance = Distance/max(Distance)) %>% 
  group_by(idTree) %>% 
  summarise(Idist = sum(Area*exp(-Distance))) %>% 
  full_join(data) %>% 
  ggplot(aes(Idist, BT, size = DBH, aes = DBH,
             col = Bark, group = NA)) +
  geom_point() +
  geom_smooth()
```

## Disturbance model

$$BT_i \sim \mathcal{N} (\sum _{j<20m} S_j^\beta * e^{-\alpha*d_{i,j}} , \sigma) $$

```{stan Mgaps, output.var="Mgaps", echo=T, eval=F}
  data {
    int N ; // # obs
    int J ; // # gaps
    real BT[N] ;
    real Area[J] ;
    real Distance[J] ;
    int individual[J] ;
  }
  parameters {
    real alpha ;
    real beta ;
    real<lower=0, upper=1> alpha_Idist ;
    real<lower=0, upper=3> beta_Idist ;
    real<lower=0> sigma ;
  }
  transformed parameters {
    real Idist[N] ;
    for(n in 1:N)
      Idist[n] = 0 ;
    for(j in 1:J)
      Idist[individual[j]] = Idist[individual[j]] + Area[j]^beta_Idist*exp(-alpha_Idist*Distance[j]) ;
  }
  model {
    for(n in 1:N)
      BT[n] ~ normal(alpha + beta*Idist[n], sigma) ;
  }
  generated quantities {
    real BTpred[N] ;
    for(n in 1:N)
      BTpred[n] = alpha + beta*Idist[n] ;
  }
```

```{r fitMgaps}
# fit <- sampling(Mgaps, chains = 2,
#                 data = list(N = nrow(arrange(data, idTree)),
#                             J = nrow(arrange(Gaps, idTree)),
#                             BT = arrange(data, idTree)$BT,
#                             Area = arrange(Gaps, idTree)$Area,
#                             Distance = arrange(Gaps, idTree)$Distance,
#                             individual = as.numeric(as.factor(arrange(Gaps, idTree)$idTree))))
# save(fit, file = "./functional_save/ModelBTGaps.Rdata")
load("./functional_save/ModelBTGaps.Rdata")
pars <- c("alpha", "beta", "alpha_Idist", "beta_Idist", "sigma")
alpha <- broom::tidyMCMC(fit, pars = "alpha_Idist")$estimate
beta <- broom::tidyMCMC(fit, pars = "beta_Idist")$estimate
broom::tidyMCMC(fit, pars = c(pars, "lp__"), droppars = NULL, rhat = T) %>% 
  kable(caption = "Summary table of the model gaps only")
```

```{r Cgaps, fig.cap="Model parameters posterior for model gaps only."}
mcmc_intervals(as.array(fit), pars = pars)
```

```{r Tgaps, fig.cap="Markov chains trace plot after warmup for model gaps only"}
mcmc_trace(as.array(fit), pars = c(pars, "lp__"),
           facet_args = list(labeller = label_parsed))
```

```{r 2gaps, fig.cap="Markov chains pairs plot after warmup for model gaps only"}
mcmc_pairs(as.array(fit), pars = c(pars, "lp__"))
```

```{r Ygaps, fig.cap="Predictions for model gaps only"}
cbind(
  Gaps %>% 
    group_by(idTree) %>% 
    summarise(Idisturb = sum(Area^beta*exp(-alpha*Distance))) %>% 
    left_join(data),
  pred = apply(as.matrix(fit, pars = "BTpred"), 2, mean),
  t(apply(as.matrix(fit, pars = "BTpred"), 2, quantile, probs = c(0.05, 0.95)))
) %>% 
  ggplot(aes(x = Idisturb)) +
  geom_point(aes(y = BT, size = DBH)) +
  geom_text(aes(y = BT, label = idTree)) +
  geom_line(aes(y = pred), col = "red") +
  geom_ribbon(aes(ymin = `5%`, ymax = `95%`), color = 'red', alpha = 0.2) +
  geom_line(aes(y = `5%`), col = "red", alpha = 1, size = 0.5, linetype = "dashed") +
  geom_line(aes(y = `95%`), col = "red", alpha = 1, size = 0.5, linetype = "dashed")
```


# Discussion

# References