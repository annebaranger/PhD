---
title: "A04: SLA & Environment"
date: '`r Sys.Date()`'
output:
  bookdown::pdf_document2:
    includes:
      before_body: ./template/doc_prefix.tex
      in_header: ./template/preamble.tex
    number_sections: false
    toc: false
    keep_tex: true
  bookdown::word_document2: default
  github_document: default
  bookdown::html_document2:
    number_sections: false
    toc: true
    toc_float: yes
linestretch: 1.5
csl: /home/sylvain/Documents/Bibliography/csl/mee.csl
bibliography: /home/sylvain/Documents/Bibliography/library.bib
link-citations: yes
---

```{r setup, include=FALSE}
rm(list = ls()) ; invisible(gc()) ; set.seed(42)
library(knitr)
library(parallel)
library(tidyverse)
library(ggfortify)
library(raster)
library(rstan)
library(bayesplot)
theme_set(bayesplot::theme_default())
opts_chunk$set(
  echo = F, message = F, warning = F, fig.height = 6, fig.width = 6,
  cache = T, cache.lazy = F)
options(mc.cores = parallel::detectCores())
rstan_options(auto_write = T)
path <- "~/Documents/BIOGECO/PhD/data/Paracou/"
crs <- '+proj=longlat +datum=NAD83 +no_defs +ellps=GRS80 +towgs84=0,0,0' # global crs definition
```

```{r traits}
traits <- googlesheets::gs_title("Measures") %>% 
  googlesheets::gs_read("AllTraits") %>% 
  mutate(SLA = as.numeric(SLA), LDMC = as.numeric(LDMC))
```

```{r trees}
trees <- src_sqlite(file.path(path, "trees/Paracou.sqlite")) %>% 
  tbl("Paracou") %>% 
  filter(idTree %in% traits$idTree) %>% 
  collect() %>% 
  mutate(DBH = CircCorr*pi)
```

```{r env}
# env <- trees %>%
#   dplyr::select(idTree, Xutm, Yutm) %>%
#   unique()
# coordinates(env) <- ~Xutm + Yutm
# proj4string(env) <- '+proj=utm +zone=22 +datum=WGS84 +units=m +no_defs +ellps=WGS84 +towgs84=0,0,0'
# env <- spTransform(env, CRSobj = crs)
# topo <- stack(
#   raster(file.path(path, "topography", "DEM_1m_2015.tif")),
#   raster(file.path(path, "topography", "RelativeElevation_1m.tif")),
#   raster(file.path(path, "topography", "slope_1m.tif")),
#   raster(file.path(path, "topography", "curvature_1m.tif")),
#   raster(file.path(path, "topography", "aspect_1m.tif")),
#   raster(file.path(path, "topography", "TRI_1m.tif")),
#   raster(file.path(path, "topography", "TWI_1m.tif"))
# )
# names(topo) <- c("DEM", "RelativeElevation", "Slope", "Curvature",
#                  "Aspect", "TRI", "TWI")
# topo <- projectRaster(topo, crs = crs)
# env <- data.frame(cbind(env@data, raster::extract(topo, env)))
# rm(topo)
# save(env, file = "./functional_save/env.Rdata")
load("./functional_save/env.Rdata")
```

```{r data}
data <- traits %>%
  mutate(Dawkins = as.numeric(substr(Dawkins, 1,1))) %>% 
  left_join(dplyr::filter(trees, CensusYear == 2015)) %>%
  left_join(env) %>% 
  dplyr::filter(!is.na(SLA)) %>% 
  group_by(Bark, idTree) %>% 
  summarise_if(is.numeric, mean, na.rm =T) %>% 
  ungroup() %>% 
  mutate(DBH = DBH/max(DBH)) %>% 
  mutate(DEM = DEM/max(DEM)) %>% 
  mutate(TWI = TWI/max(TWI))
```

# Introduction

First model for SLA variation in relation to environment.

# SLA - DBH

## Relation

```{r SLADBH}
data %>% 
  ggplot(aes(DBH, SLA, col = Bark, group = NA)) +
  geom_point() +
  geom_smooth()
```

## Michealis Menten model

We will used an inverted Michealis Menten equation for DBH effect on SLA.

$$SLA \sim \mathcal{N} (\frac{dbh + \beta}{\alpha * dbh}, \sigma) $$

```{stan Mdbh, output.var="Mdbh", echo=T, eval=F}
  data {
    int N ; // # obs
    real SLA[N] ;
    real DBH[N] ;
  }
  parameters {
    real<lower=0> alpha ;
    real<lower=0> beta ;
    real<lower=0> sigma ;
  }
  model {
    for(n in 1:N)
      SLA[n] ~ normal((DBH[n] + beta)/(alpha*DBH[n]), sigma) ;
  }
  generated quantities {
    real SLApred[N] ;
    for(n in 1:N)
      SLApred[n] = (DBH[n] + beta)/(alpha*DBH[n]) ;
  }
```

```{r fitMdbh}
# fit <- sampling(Mdbh, chains = 2,
#                 data = list(N = nrow(data),
#                             SLA = data$SLA,
#                             DBH = data$DBH))
# save(fit, file = "./functional_save/Mdbh.Rdata")
load("./functional_save/Mdbh.Rdata")
pars <- c("alpha", "beta", "sigma")
broom::tidyMCMC(fit, pars = c(pars, "lp__"), droppars = NULL, rhat = T) %>% 
  kable(caption = "Summary table of the model dbh only")
```

```{r Cdbh, fig.cap="Model parameters posterior for model dbh only."}
mcmc_intervals(as.array(fit), pars = pars)
```

```{r Tdbh, fig.cap="Markov chains trace plot after warmup for model dbh only"}
mcmc_trace(as.array(fit), pars = c(pars, "lp__"),
           facet_args = list(labeller = label_parsed))
```

```{r 2dbh, fig.cap="Markov chains pairs plot after warmup for model dbh only"}
mcmc_pairs(as.array(fit), pars = c(pars, "lp__"))
```

```{r Ydbh, fig.cap="Predictions for model dbh only"}
cbind(
  data,
  pred = apply(as.matrix(fit, pars = "SLApred"), 2, mean),
  t(apply(as.matrix(fit, pars = "SLApred"), 2, quantile, probs = c(0.05, 0.95)))
) %>% 
  ggplot(aes(x = DBH)) +
  geom_point(aes(y = SLA)) +
  geom_line(aes(y = pred), col = "red") +
  geom_ribbon(aes(ymin = `5%`, ymax = `95%`), color = 'red', alpha = 0.2) +
  geom_line(aes(y = `5%`), col = "red", alpha = 1, size = 0.5, linetype = "dashed") +
  geom_line(aes(y = `95%`), col = "red", alpha = 1, size = 0.5, linetype = "dashed")
```

## Linear model

We will used a linear equation for DBH effect on SLA.

$$SLA \sim \mathcal{N} (\alpha + \beta* dbh, \sigma) $$

```{stan MdbhLinear, output.var="MdbhLinear", echo=T, eval=F}
  data {
    int N ; // # obs
    real SLA[N] ;
    real DBH[N] ;
  }
  parameters {
    real alpha ;
    real beta ;
    real<lower=0> sigma ;
  }
  model {
    for(n in 1:N)
      SLA[n] ~ normal(alpha + beta*DBH[n], sigma) ;
  }
  generated quantities {
    real SLApred[N] ;
    for(n in 1:N)
      SLApred[n] = alpha + beta*DBH[n] ;
  }
```

```{r fitMdbhLinear}
# fit <- sampling(MdbhLinear, chains = 2,
#                 data = list(N = nrow(data),
#                             SLA = data$SLA,
#                             DBH = data$DBH))
# save(fit, file = "./functional_save/MdbhLinear.Rdata")
load("./functional_save/MdbhLinear.Rdata")
pars <- c("alpha", "beta", "sigma")
broom::tidyMCMC(fit, pars = c(pars, "lp__"), droppars = NULL, rhat = T) %>% 
  kable(caption = "Summary table of the model dbh only")
```

```{r CdbhLinear, fig.cap="Model parameters posterior for model dbh only."}
mcmc_intervals(as.array(fit), pars = pars)
```

```{r TdbhLinear, fig.cap="Markov chains trace plot after warmup for model dbh only"}
mcmc_trace(as.array(fit), pars = c(pars, "lp__"),
           facet_args = list(labeller = label_parsed))
```

```{r 2dbhLinear, fig.cap="Markov chains pairs plot after warmup for model dbh only"}
mcmc_pairs(as.array(fit), pars = c(pars, "lp__"))
```

```{r YdbhLinear, fig.cap="Predictions for model dbh only"}
cbind(
  data,
  pred = apply(as.matrix(fit, pars = "SLApred"), 2, mean),
  t(apply(as.matrix(fit, pars = "SLApred"), 2, quantile, probs = c(0.05, 0.95)))
) %>% 
  ggplot(aes(x = DBH)) +
  geom_point(aes(y = SLA)) +
  geom_line(aes(y = pred), col = "red") +
  geom_ribbon(aes(ymin = `5%`, ymax = `95%`), color = 'red', alpha = 0.2) +
  geom_line(aes(y = `5%`), col = "red", alpha = 1, size = 0.5, linetype = "dashed") +
  geom_line(aes(y = `95%`), col = "red", alpha = 1, size = 0.5, linetype = "dashed")
```

In conclusion the likelihood is better for the Michaelis Menten form that we will use in following models.

# SLA - TWI

## Relation

```{r SLATWI}
data %>% 
  ggplot(aes(TWI, SLA, size = DBH, aes = DBH,
             col = Bark)) +
  geom_point()
```

## Linear model

We will used a linear equation for TWI effect on SLA.

$$SLA \sim \mathcal{N} (\alpha + \beta* TWI, \sigma) $$

```{stan MTWI, output.var="MTWI", echo=T, eval=F}
  data {
    int N ; // # obs
    real SLA[N] ;
    real TWI[N] ;
  }
  parameters {
    real alpha ;
    real beta ;
    real<lower=0> sigma ;
  }
  model {
    for(n in 1:N)
      SLA[n] ~ normal(alpha + beta*TWI[n], sigma) ;
  }
  generated quantities {
    real SLApred[N] ;
    for(n in 1:N)
      SLApred[n] = alpha + beta*TWI[n] ;
  }
```

```{r fitMTWILinear}
# fit <- sampling(MTWI, chains = 2,
#                 data = list(N = nrow(data),
#                             SLA = data$SLA,
#                             TWI = data$TWI))
# save(fit, file = "./functional_save/MTWILinear.Rdata")
load("./functional_save/MTWILinear.Rdata")
pars <- c("alpha", "beta", "sigma")
broom::tidyMCMC(fit, pars = c(pars, "lp__"), droppars = NULL, rhat = T) %>% 
  kable(caption = "Summary table of the model v only")
```

```{r CTWILinear, fig.cap="Model parameters posterior for model TWI only."}
mcmc_intervals(as.array(fit), pars = pars)
```

```{r TTWILinear, fig.cap="Markov chains trace plot after warmup for model TWI only"}
mcmc_trace(as.array(fit), pars = c(pars, "lp__"),
           facet_args = list(labeller = label_parsed))
```

```{r 2TWILinear, fig.cap="Markov chains pairs plot after warmup for model TWI only"}
mcmc_pairs(as.array(fit), pars = c(pars, "lp__"))
```

```{r YTWILinear, fig.cap="Predictions for model TWI only"}
cbind(
  data,
  pred = apply(as.matrix(fit, pars = "SLApred"), 2, mean),
  t(apply(as.matrix(fit, pars = "SLApred"), 2, quantile, probs = c(0.05, 0.95)))
) %>% 
  ggplot(aes(x = TWI)) +
  geom_point(aes(y = SLA)) +
  geom_line(aes(y = pred), col = "red") +
  geom_ribbon(aes(ymin = `5%`, ymax = `95%`), color = 'red', alpha = 0.2) +
  geom_line(aes(y = `5%`), col = "red", alpha = 1, size = 0.5, linetype = "dashed") +
  geom_line(aes(y = `95%`), col = "red", alpha = 1, size = 0.5, linetype = "dashed")
```

Topographic wetness index as no effect on SLA.

# SLA - Elevation

## Relation

```{r SLAElevation}
data %>% 
  ggplot(aes(DEM, SLA, size = DBH, aes = DBH,
             col = Bark, group = NA)) +
  geom_point()
```

## Linear model

We will used a linear equation for elevation effect on SLA.

$$SLA \sim \mathcal{N} (\alpha + \beta* Elevation, \sigma) $$

```{stan MElevation, output.var="MElevation", echo=T, eval=F}
  data {
    int N ; // # obs
    real SLA[N] ;
    real Elevation[N] ;
  }
  parameters {
    real alpha ;
    real beta ;
    real<lower=0> sigma ;
  }
  model {
    for(n in 1:N)
      SLA[n] ~ normal(alpha + beta*Elevation[n], sigma) ;
  }
  generated quantities {
    real SLApred[N] ;
    for(n in 1:N)
      SLApred[n] = alpha + beta*Elevation[n] ;
  }
```

```{r fitMElevation}
# fit <- sampling(MElevation, chains = 2,
#                 data = list(N = nrow(data),
#                             SLA = data$SLA,
#                             Elevation = data$DEM))
# save(fit, file = "./functional_save/MElevation.Rdata")
load("./functional_save/MElevation.Rdata")
pars <- c("alpha", "beta", "sigma")
broom::tidyMCMC(fit, pars = c(pars, "lp__"), droppars = NULL, rhat = T) %>% 
  kable(caption = "Summary table of the model Elevation only")
```

```{r CElevationLinear, fig.cap="Model parameters posterior for model Elevation only."}
mcmc_intervals(as.array(fit), pars = pars)
```

```{r TElevationLinear, fig.cap="Markov chains trace plot after warmup for model Elevation only"}
mcmc_trace(as.array(fit), pars = c(pars, "lp__"),
           facet_args = list(labeller = label_parsed))
```

```{r 2ElevationLinear, fig.cap="Markov chains pairs plot after warmup for model Elevation only"}
mcmc_pairs(as.array(fit), pars = c(pars, "lp__"))
```

```{r YElevationLinear, fig.cap="Predictions for model Elevation only"}
cbind(
  data,
  pred = apply(as.matrix(fit, pars = "SLApred"), 2, mean),
  t(apply(as.matrix(fit, pars = "SLApred"), 2, quantile, probs = c(0.05, 0.95)))
) %>% 
  ggplot(aes(x = DEM)) +
  geom_point(aes(y = SLA)) +
  geom_line(aes(y = pred), col = "red") +
  geom_ribbon(aes(ymin = `5%`, ymax = `95%`), color = 'red', alpha = 0.2) +
  geom_line(aes(y = `5%`), col = "red", alpha = 1, size = 0.5, linetype = "dashed") +
  geom_line(aes(y = `95%`), col = "red", alpha = 1, size = 0.5, linetype = "dashed")
```

Elevation as a slight, almost null, positive effect on SLA.

# SLA - Competition

```{r dataCompetition}
# cl <- makeCluster(4)
# clusterExport(cl, list("data", "path"))
# Competition <- clusterMap(cl,
#   function(id, plot, x, y){
#   library(dplyr)
#   src_sqlite(file.path(path, "trees/Paracou.sqlite")) %>%
#     tbl("Paracou") %>%
#     filter(CensusYear == 2005) %>%
#     filter(Plot == plot) %>% 
#     filter(idTree != id) %>% 
#     mutate(DBH = CircCorr*pi) %>%
#     mutate(dij = sqrt((x - Xutm)^2+(y - Yutm)^2)) %>%
#     filter(dij < 20) %>%
#     mutate(idTreej = idTree) %>%
#     mutate(idTreei = id) %>%
#     dplyr::select(idTreei, idTreej, DBH, dij) %>%
#     collect()},
#   id = data$idTree,
#   plot = data$Plot,
#   x = data$Xutm,
#   y = data$Yutm,
#   SIMPLIFY = F)
# stopCluster(cl)
# rm(cl)
# Competition <- bind_rows(Competition)
# Competition <- Competition %>% 
#   mutate(dij = ifelse(dij < 0.4, 0.4, dij)) # measure precision error troubling NCI fit 
# save(Competition, file = "./functional_save/CompetitionMatrix.Rdata")
load("./functional_save/CompetitionMatrix.Rdata")
```

## Relation

```{r SLACompetition}
Competition %>% 
  group_by(idTreei) %>% 
  summarise(NCI = sum(DBH*exp(-dij))) %>% 
  left_join(data, by = c("idTreei" = "idTree")) %>% 
  ggplot(aes(NCI, SLA, size = DBH, aes = DBH,
             col = Bark, group = NA)) +
  geom_point() +
  geom_smooth()
```

## Competition model

$$SLA_i \sim \mathcal{N} (\sum _{j<20m} DBH_j^\beta * e^{-\alpha*d_{i,j}} , \sigma) $$

```{stan Mcomp, output.var="Mcomp", echo=T, eval=F}
  data {
    int N ; // # obs
    int J ; // # neighbours
    real SLA[N] ;
    real DBH[J] ;
    real dij[J] ;
    int individual[J] ;
  }
  parameters {
    real<lower=-1, upper=1> alpha ;
    real<lower=-3, upper=3> beta ;
    real<lower=0> sigma ;
  }
  transformed parameters {
    real NCI[N] ;
    for(n in 1:N)
      NCI[n] = 0 ;
    for(j in 1:J)
      NCI[individual[j]] = NCI[individual[j]] + DBH[j]^beta*exp(-alpha*dij[j]) ;
  }
  model {
    for(n in 1:N)
      SLA[n] ~ normal(NCI[n], sigma) ;
  }
  generated quantities {
    real SLApred[N] ;
    for(n in 1:N)
      SLApred[n] = NCI[n] ;
  }
```

```{r fitMcomp}
# fit <- sampling(Mcomp, chains = 2,
#                 data = list(N = nrow(arrange(data, idTree)),
#                             J = nrow(arrange(Competition, idTreei)),
#                             SLA = arrange(data, idTree)$SLA,
#                             DBH = arrange(Competition, idTreei)$DBH,
#                             dij = arrange(Competition, idTreei)$dij,
#                             individual = as.numeric(as.factor(arrange(Competition, idTreei)$idTreei))))
# save(fit, file = "./functional_save/ModelSLACompetition.Rdata")
load("./functional_save/ModelSLACompetition.Rdata")
pars <- c("alpha", "beta", "sigma")
alpha <- broom::tidyMCMC(fit, pars = "alpha")$estimate
beta <- broom::tidyMCMC(fit, pars = "beta")$estimate
broom::tidyMCMC(fit, pars = c(pars, "lp__"), droppars = NULL, rhat = T) %>% 
  kable(caption = "Summary table of the model competition only")
```

```{r Ccomp, fig.cap="Model parameters posterior for model competition only."}
mcmc_intervals(as.array(fit), pars = pars)
```

```{r Tcomp, fig.cap="Markov chains trace plot after warmup for model competition only"}
mcmc_trace(as.array(fit), pars = c(pars, "lp__"),
           facet_args = list(labeller = label_parsed))
```

```{r 2comp, fig.cap="Markov chains pairs plot after warmup for model competition only"}
mcmc_pairs(as.array(fit), pars = c(pars, "lp__"))
```

```{r Ycomp, fig.cap="Predictions for model competition only"}
cbind(
  Competition %>% 
    group_by(idTreei) %>% 
    summarise(NCI = sum(DBH^beta*exp(-alpha*dij))) %>% 
    left_join(data, by = c("idTreei" = "idTree")),
  pred = apply(as.matrix(fit, pars = "SLApred"), 2, mean),
  t(apply(as.matrix(fit, pars = "SLApred"), 2, quantile, probs = c(0.05, 0.95)))
) %>% 
  ggplot(aes(x = NCI)) +
  geom_point(aes(y = SLA)) +
  geom_text(aes(y = SLA, label = idTreei)) +
  geom_line(aes(y = pred), col = "red") +
  geom_ribbon(aes(ymin = `5%`, ymax = `95%`), color = 'red', alpha = 0.2) +
  geom_line(aes(y = `5%`), col = "red", alpha = 1, size = 0.5, linetype = "dashed") +
  geom_line(aes(y = `95%`), col = "red", alpha = 1, size = 0.5, linetype = "dashed")
```

# SLA - Gaps

```{r dataGaps}
# gaps <- shapefile(file.path(path, "topography", "Gaps", "gaps4.shp"))
# crs(gaps) <- crs(raster(file.path(path, "biotic", "MNC_ParacouAvril2009_1m.tif")))
# gaps <- spTransform(gaps, '+proj=utm +zone=22 +datum=WGS84 +units=m +no_defs +ellps=WGS84 +towgs84=0,0,0')
# cl <- makeCluster(4)
# clusterExport(cl, list("data", "gaps"))
# Gaps <- clusterMap(cl,
#   function(id,  x, y){
#     d <- 50
#     gaps_sel <- raster::crop(rgeos::gBuffer(gaps, byid=TRUE, width=0), 
#                              raster::extent(matrix(c(x-d, y-d, x+d, y+d), nrow=2)))
#     tree <- data.frame(x = x, y = y)
#     sp::coordinates(tree) <- ~x+y
#     raster::crs(tree) <-  '+proj=utm +zone=22 +datum=WGS84 +units=m +no_defs +ellps=WGS84 +towgs84=0,0,0'
#     if(!is.null(gaps_sel))
#       data.frame(idTree = id,
#                  idGap = gaps_sel$fid,
#                  Area = raster::area(gaps_sel),
#                  Distance = rgeos::gDistance(tree, gaps_sel, byid = T)[,1])
#     },
#   id = data$idTree,
#   x = data$Xutm,
#   y = data$Yutm,
#   SIMPLIFY = F)
# stopCluster(cl)
# rm(cl)
# Gaps <- bind_rows(Gaps)
# Gaps <- Gaps %>% 
#   filter(Area < 500)
# Gaps <- Gaps %>%
#   full_join(dplyr::select(data, idTree)) %>%
#   mutate(Area = ifelse(is.na(Area), 0, Area)) %>%
#   mutate(Distance = ifelse(is.na(Distance), 100, Distance))
# save(Gaps, file = "./functional_save/GapsMatrix.Rdata")
load("./functional_save/GapsMatrix.Rdata")
```

## Relation

```{r SLAGaps}
Gaps %>% 
  filter(Area < 500) %>%
  mutate(Area = Area/max(Area)) %>% 
  mutate(Distance = Distance/max(Distance)) %>% 
  group_by(idTree) %>% 
  summarise(Idist = sum(Area*exp(-Distance))) %>% 
  left_join(data) %>% 
  ggplot(aes(Idist, SLA, size = DBH, aes = DBH,
             col = Bark, group = NA)) +
  geom_point() +
  geom_smooth()
```

## Disturbance model

$$SLA_i \sim \mathcal{N} (\alpha + \beta*\sum _{j<20m} S_j^\beta * e^{-\alpha*d_{i,j}} , \sigma) $$

```{stan Mgaps, output.var="Mgaps", echo=T, eval=F}
  data {
    int N ; // # obs
    int J ; // # gaps
    real SLA[N] ;
    real Area[J] ;
    real Distance[J] ;
    int individual[J] ;
  }
  parameters {
    real alpha ;
    real beta ;
    real<lower=0, upper=1> alpha_Idist ;
    real<lower=0, upper=3> beta_Idist ;
    real<lower=0> sigma ;
  }
  transformed parameters {
    real Idist[N] ;
    for(n in 1:N)
      Idist[n] = 0 ;
    for(j in 1:J)
      Idist[individual[j]] = Idist[individual[j]] + Area[j]^beta_Idist*exp(-alpha_Idist*Distance[j]) ;
  }
  model {
    for(n in 1:N)
      SLA[n] ~ normal(alpha + beta*Idist[n], sigma) ;
  }
  generated quantities {
    real SLApred[N] ;
    for(n in 1:N)
      SLApred[n] = alpha + beta*Idist[n] ;
  }
```

```{r fitMgaps}
# fit <- sampling(Mgaps, chains = 2,
#                 data = list(N = nrow(arrange(data, idTree)),
#                             J = nrow(arrange(Gaps, idTree)),
#                             SLA = arrange(data, idTree)$SLA,
#                             Area = arrange(Gaps, idTree)$Area,
#                             Distance = arrange(Gaps, idTree)$Distance,
#                             individual = as.numeric(as.factor(arrange(Gaps, idTree)$idTree))))
# save(fit, file = "./functional_save/ModelSLAGaps.Rdata")
load("./functional_save/ModelSLAGaps.Rdata")
pars <- c("alpha", "beta", "alpha_Idist", "beta_Idist", "sigma")
alpha <- broom::tidyMCMC(fit, pars = "alpha_Idist")$estimate
beta <- broom::tidyMCMC(fit, pars = "beta_Idist")$estimate
broom::tidyMCMC(fit, pars = c(pars, "lp__"), droppars = NULL, rhat = T) %>% 
  kable(caption = "Summary table of the model gaps only")
```

```{r Cgaps, fig.cap="Model parameters posterior for model gaps only."}
mcmc_intervals(as.array(fit), pars = pars)
```

```{r Tgaps, fig.cap="Markov chains trace plot after warmup for model gaps only"}
mcmc_trace(as.array(fit), pars = c(pars, "lp__"),
           facet_args = list(labeller = label_parsed))
```

```{r 2gaps, fig.cap="Markov chains pairs plot after warmup for model gaps only"}
mcmc_pairs(as.array(fit), pars = c(pars, "lp__"))
```

```{r Ygaps, fig.cap="Predictions for model gaps only"}
cbind(
  Gaps %>% 
    group_by(idTree) %>% 
    summarise(Idisturb = sum(Area^beta*exp(-alpha*Distance))) %>% 
    left_join(data),
  pred = apply(as.matrix(fit, pars = "SLApred"), 2, mean),
  t(apply(as.matrix(fit, pars = "SLApred"), 2, quantile, probs = c(0.05, 0.95)))
) %>% 
  ggplot(aes(x = Idisturb)) +
  geom_point(aes(y = SLA, size = DBH)) +
  geom_text(aes(y = SLA, label = idTree)) +
  geom_line(aes(y = pred), col = "red") +
  geom_ribbon(aes(ymin = `5%`, ymax = `95%`), color = 'red', alpha = 0.2) +
  geom_line(aes(y = `5%`), col = "red", alpha = 1, size = 0.5, linetype = "dashed") +
  geom_line(aes(y = `95%`), col = "red", alpha = 1, size = 0.5, linetype = "dashed")
```

# SLA - All

## Relation

```{r SLAAll}
data %>% 
  left_join(Competition %>% 
              group_by(idTreei) %>% 
              summarise(NCI = sum(DBH*exp(-dij))),
            by = c("idTree" = "idTreei")) %>% 
  left_join(Gaps %>% 
              group_by(idTree) %>% 
              mutate(Area = Area/max(Area)) %>% 
              mutate(Distance = Distance/max(Distance)) %>% 
              summarise(Idist = sum(Area*exp(-Distance)))) %>% 
  dplyr::select(Bark, SLA, DBH, TWI, NCI, Idist) %>%
  mutate(DBH0 = DBH) %>% 
  reshape2::melt(id.vars = c("Bark", "SLA", "DBH0")) %>% 
  ggplot(aes(value, SLA, size = DBH0, aes = DBH0,
             col = Bark, group = NA)) +
  geom_point() +
  facet_wrap(~ variable, scales = "free", nrow = 2) +
  geom_smooth()
```

## Full model

$$SLA \sim \mathcal{N} (\frac{dbh + \beta_{DBH}}{\alpha_{DBH} * dbh} +  \beta_{TWI}*TWI + \beta_{Competition}*\sum _{j<20m} DBH_j^{\beta_{NCI}} * e^{-\alpha_{NCI}*d_{i,j}} + \beta_Gaps*\sum _{k<50m} S_k^\beta * e^{-\alpha*d_{i,k}}, \sigma) $$

```{stan Mall, output.var="Mall", echo=T, eval=F}
  data {
    int N ; // # obs
    real SLA[N] ;
    real DBH[N] ;
    real TWI[N] ;
    int J ; // # neighbours
    real DBHj[J] ;
    real dij[J] ;
    int individualJ[J] ;
    int K ; // # gaps
    real Area[K] ;
    real Distance[K] ;
    int individualK[K] ;
  }
  parameters {
    real<lower=0> alpha_DBH ;
    real<lower=0> beta_DBH ;
    real beta_TWI ;
    real beta_Competition ;
    real<lower=0, upper=1> alpha_NCI ;
    real<lower=0, upper=3> beta_NCI ;
    real beta_Gaps ;
    real<lower=0, upper=1> alpha_Idist ;
    real<lower=0, upper=3> beta_Idist ;
    real<lower=0> sigma ;
  }
  transformed parameters {
    real NCI[N] ;
    real Idist[N] ;
    for(n in 1:N){
      NCI[n] = 0 ;
      Idist[n] = 0 ;
    }
    for(j in 1:J)
      NCI[individualJ[j]] = NCI[individualJ[j]] + DBHj[j]^beta_NCI*exp(-alpha_NCI*dij[j]) ;
    for(k in 1:K)
      Idist[individualK[k]] = Idist[individualK[k]] + Area[k]^beta_Idist*exp(-alpha_Idist*Distance[k]) ;
  }
  model {
    for(n in 1:N)
      SLA[n] ~ normal((DBH[n] + beta_DBH)/(alpha_DBH*DBH[n]) + beta_TWI*TWI[n] +  beta_Competition*NCI[n] + beta_Gaps*Idist[n], sigma) ;
  }
  generated quantities {
    real SLApred[N] ;
    for(n in 1:N)
      SLApred[n] = (DBH[n] + beta_DBH)/(alpha_DBH*DBH[n]) + beta_TWI*TWI[n] + NCI[n] + beta_Gaps*Idist[n] ;
  }
```

```{r fitMall}
# fit <- sampling(Mall, chains = 2,
#                 data = list(N = nrow(arrange(data, idTree)),
#                             SLA = arrange(data, idTree)$SLA,
#                             DBH = arrange(data, idTree)$DBH,
#                             TWI = arrange(data, idTree)$TWI,
#                             J = nrow(arrange(Competition, idTreei)),
#                             DBHj = arrange(Competition, idTreei)$DBH,
#                             dij = arrange(Competition, idTreei)$dij,
#                             individualJ = as.numeric(as.factor(arrange(Competition, idTreei)$idTreei)),
#                             K = nrow(arrange(Gaps, idTree)),
#                             Area = arrange(Gaps, idTree)$Area,
#                             Distance = arrange(Gaps, idTree)$Distance,
#                             individualK = as.numeric(as.factor(arrange(Gaps, idTree)$idTree))))
# save(fit, file = "./functional_save/MSLAall.Rdata")
load("./functional_save/MSLAall.Rdata")
pars <- c("alpha_DBH", "beta_DBH", "beta_TWI", 
          "beta_Competition", "alpha_NCI", "beta_NCI", 
          "beta_Gaps", "alpha_Idist", "beta_Idist", "sigma")
alpha_NCI <- broom::tidyMCMC(fit, pars = "alpha_NCI")$estimate
beta_NCI <- broom::tidyMCMC(fit, pars = "beta_NCI")$estimate
alpha_Idist <- broom::tidyMCMC(fit, pars = "alpha_Idist")$estimate
beta_Idist <- broom::tidyMCMC(fit, pars = "beta_Idist")$estimate
broom::tidyMCMC(fit, pars = c(pars, "lp__"), droppars = NULL, rhat = T) %>% 
  kable(caption = "Summary table of the model dbh only")
```

```{r Call, fig.cap="Model parameters posterior for full model."}
mcmc_intervals(as.array(fit), pars = pars)
```

```{r CbetaAll, fig.cap="Model parameters posterior for full model."}
mcmc_intervals(as.array(fit), 
               pars = c("alpha_DBH", "beta_TWI", "beta_Competition", "beta_Gaps"))
```

```{r Tall, fig.cap="Markov chains trace plot after warmup for full model"}
mcmc_trace(as.array(fit), pars = c(pars, "lp__"),
           facet_args = list(labeller = label_parsed))
```

```{r 2all, fig.cap="Markov chains pairs plot after warmup for full model"}
mcmc_pairs(as.array(fit), pars = c(pars, "lp__"))
```

```{r Yall, fig.cap="Predictions for full model"}
cbind(
  data %>% 
    left_join(Competition %>% 
                group_by(idTreei) %>% 
                summarise(NCI = sum(DBH^beta_NCI*exp(-alpha_NCI*dij))),
              by = c("idTree" = "idTreei")) %>% 
    left_join(Gaps %>% 
                group_by(idTree) %>% 
                summarise(Idist = sum(Area^beta_Idist*exp(-alpha_Idist*Distance)))) %>% 
    dplyr::select(Bark, SLA, DBH, TWI, NCI, Idist) %>%
    mutate(DBH0 = DBH) %>% 
    reshape2::melt(id.vars = c("Bark", "SLA", "DBH0")),
  pred = apply(as.matrix(fit, pars = "SLApred"), 2, mean),
  t(apply(as.matrix(fit, pars = "SLApred"), 2, quantile, probs = c(0.05, 0.95)))
) %>% 
  ggplot(aes(value, group = NA)) +
  geom_point(aes(y = SLA, size = DBH0, aes = DBH0, col = Bark)) +
  geom_line(aes(y = pred), col = "red") +
  geom_ribbon(aes(ymin = `5%`, ymax = `95%`), color = 'red', alpha = 0.2) +
  geom_line(aes(y = `5%`), col = "red", alpha = 1, size = 0.5, linetype = "dashed") +
  geom_line(aes(y = `95%`), col = "red", alpha = 1, size = 0.5, linetype = "dashed") +
  facet_wrap(~ variable, nrow = 2, scales = "free")
```

# SLA - All except Gaps

## Relation

```{r SLAAllexceptGaps}
data %>% 
  left_join(Competition %>% 
              group_by(idTreei) %>% 
              summarise(NCI = sum(DBH*exp(-dij))),
            by = c("idTree" = "idTreei")) %>% 
  dplyr::select(Bark, SLA, DBH, TWI, NCI) %>%
  mutate(DBH0 = DBH) %>% 
  reshape2::melt(id.vars = c("Bark", "SLA", "DBH0")) %>% 
  ggplot(aes(value, SLA, size = DBH0, aes = DBH0,
             col = Bark, group = NA)) +
  geom_point() +
  facet_wrap(~ variable, scales = "free", nrow = 2) +
  geom_smooth()
```

## Full model

$$SLA \sim \mathcal{N} (\frac{dbh + \beta_{DBH}}{\alpha_{DBH} * dbh} +  \beta_{TWI}*TWI + \beta_{Competition}*\sum _{j<20m} DBH_j^{\beta_{NCI}} * e^{-\alpha_{NCI}*d_{i,j}}, \sigma) $$

```{stan MallExceptGaps, output.var="MallExceptGaps", echo=T, eval=F}
  data {
    int N ; // # obs
    real SLA[N] ;
    real DBH[N] ;
    real TWI[N] ;
    int J ; // # neighbours
    real DBHj[J] ;
    real dij[J] ;
    int individualJ[J] ;
  }
  parameters {
    real<lower=0> alpha_DBH ;
    real<lower=0> beta_DBH ;
    real beta_TWI ;
    real beta_Competition ;
    real<lower=0, upper=1> alpha_NCI ;
    real<lower=0, upper=3> beta_NCI ;
    real<lower=0> sigma ;
  }
  transformed parameters {
    real NCI[N] ;
    for(n in 1:N){
      NCI[n] = 0 ;
    }
    for(j in 1:J)
      NCI[individualJ[j]] = NCI[individualJ[j]] + DBHj[j]^beta_NCI*exp(-alpha_NCI*dij[j]) ;
  }
  model {
    for(n in 1:N)
      SLA[n] ~ normal((DBH[n] + beta_DBH)/(alpha_DBH*DBH[n]) + beta_TWI*TWI[n] +  beta_Competition*NCI[n], sigma) ;
  }
  generated quantities {
    real SLApred[N] ;
    for(n in 1:N)
      SLApred[n] = (DBH[n] + beta_DBH)/(alpha_DBH*DBH[n]) + beta_TWI*TWI[n] + NCI[n] ;
  }
```

```{r fitMallExceptGaps}
fit <- sampling(MallExceptGaps, chains = 2,
                data = list(N = nrow(arrange(data, idTree)),
                            SLA = arrange(data, idTree)$SLA,
                            DBH = arrange(data, idTree)$DBH,
                            TWI = arrange(data, idTree)$TWI,
                            J = nrow(arrange(Competition, idTreei)),
                            DBHj = arrange(Competition, idTreei)$DBH,
                            dij = arrange(Competition, idTreei)$dij,
                            individualJ = as.numeric(as.factor(arrange(Competition, idTreei)$idTreei))))
save(fit, file = "./functional_save/MSLAallExceptGaps.Rdata")
load("./functional_save/MSLAallExceptGaps.Rdata")
pars <- c("alpha_DBH", "beta_DBH", "beta_TWI", 
          "beta_Competition", "alpha_NCI", "beta_NCI", "sigma")
alpha_NCI <- broom::tidyMCMC(fit, pars = "alpha_NCI")$estimate
beta_NCI <- broom::tidyMCMC(fit, pars = "beta_NCI")$estimate
broom::tidyMCMC(fit, pars = c(pars, "lp__"), droppars = NULL, rhat = T) %>% 
  kable(caption = "Summary table of the model dbh only")
```

```{r Call, fig.cap="Model parameters posterior for full model."}
mcmc_intervals(as.array(fit), pars = pars)
```

```{r CbetaAll, fig.cap="Model parameters posterior for full model."}
mcmc_intervals(as.array(fit), 
               pars = c("alpha_DBH", "beta_TWI", "beta_Competition", "beta_Gaps"))
```

```{r Tall, fig.cap="Markov chains trace plot after warmup for full model"}
mcmc_trace(as.array(fit), pars = c(pars, "lp__"),
           facet_args = list(labeller = label_parsed))
```

```{r 2all, fig.cap="Markov chains pairs plot after warmup for full model"}
mcmc_pairs(as.array(fit), pars = c(pars, "lp__"))
```

```{r Yall, fig.cap="Predictions for full model"}
cbind(
  data %>% 
    left_join(Competition %>% 
                group_by(idTreei) %>% 
                summarise(NCI = sum(DBH^beta_NCI*exp(-alpha_NCI*dij))),
              by = c("idTree" = "idTreei")) %>% 
    left_join(Gaps %>% 
                group_by(idTree) %>% 
                summarise(Idist = sum(Area^beta_Idist*exp(-alpha_Idist*Distance)))) %>% 
    dplyr::select(Bark, SLA, DBH, TWI, NCI, Idist) %>%
    mutate(DBH0 = DBH) %>% 
    reshape2::melt(id.vars = c("Bark", "SLA", "DBH0")),
  pred = apply(as.matrix(fit, pars = "SLApred"), 2, mean),
  t(apply(as.matrix(fit, pars = "SLApred"), 2, quantile, probs = c(0.05, 0.95)))
) %>% 
  ggplot(aes(value, group = NA)) +
  geom_point(aes(y = SLA, size = DBH0, aes = DBH0, col = Bark)) +
  geom_line(aes(y = pred), col = "red") +
  geom_ribbon(aes(ymin = `5%`, ymax = `95%`), color = 'red', alpha = 0.2) +
  geom_line(aes(y = `5%`), col = "red", alpha = 1, size = 0.5, linetype = "dashed") +
  geom_line(aes(y = `95%`), col = "red", alpha = 1, size = 0.5, linetype = "dashed") +
  facet_wrap(~ variable, nrow = 2, scales = "free")
```

# Discussion

# References
