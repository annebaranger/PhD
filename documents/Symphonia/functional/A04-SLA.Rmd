---
title: "A04: SLA & Environment"
date: '`r Sys.Date()`'
output:
  bookdown::html_document2:
    number_sections: false
    toc: true
    toc_float: yes
  bookdown::word_document2: default
  github_document: default
  bookdown::pdf_document2:
    includes:
      before_body: ./template/doc_prefix.tex
      in_header: ./template/preamble.tex
    number_sections: false
    toc: false
    keep_tex: true
linestretch: 1.5
csl: /home/sylvain/Documents/Bibliography/csl/mee.csl
bibliography: /home/sylvain/Documents/Bibliography/library.bib
link-citations: yes
---

```{r setup, include=FALSE}
rm(list = ls()) ; invisible(gc()) ; set.seed(42)
library(knitr)
library(parallel)
library(tidyverse)
library(ggfortify)
library(raster)
library(rstan)
library(bayesplot)
theme_set(bayesplot::theme_default())
opts_chunk$set(
  echo = F, message = F, warning = F, fig.height = 6, fig.width = 6,
  cache = T, cache.lazy = F)
options(mc.cores = parallel::detectCores())
rstan_options(auto_write = T)
path <- "~/Documents/BIOGECO/PhD/data/Paracou/"
crs <- '+proj=longlat +datum=NAD83 +no_defs +ellps=GRS80 +towgs84=0,0,0' # global crs definition
```

```{r traits}
traits <- googlesheets::gs_title("Measures") %>% 
  googlesheets::gs_read("AllTraits") %>% 
  mutate(SLA = as.numeric(SLA), LDMC = as.numeric(LDMC))
```

```{r trees}
trees <- src_sqlite(file.path(path, "trees/Paracou.sqlite")) %>% 
  tbl("Paracou") %>% 
  filter(idTree %in% traits$idTree) %>% 
  collect() %>% 
  mutate(DBH = CircCorr*pi)
```

```{r env}
# env <- trees %>%
#   dplyr::select(idTree, Xutm, Yutm) %>%
#   unique()
# coordinates(env) <- ~Xutm + Yutm
# proj4string(env) <- '+proj=utm +zone=22 +datum=WGS84 +units=m +no_defs +ellps=WGS84 +towgs84=0,0,0'
# env <- spTransform(env, CRSobj = crs)
# topo <- stack(
#   raster(file.path(path, "topography", "DEM_1m_2015.tif")),
#   raster(file.path(path, "topography", "RelativeElevation_1m.tif")),
#   raster(file.path(path, "topography", "slope_1m.tif")),
#   raster(file.path(path, "topography", "curvature_1m.tif")),
#   raster(file.path(path, "topography", "aspect_1m.tif")),
#   raster(file.path(path, "topography", "TRI_1m.tif")),
#   raster(file.path(path, "topography", "TWI_1m.tif"))
# )
# names(topo) <- c("DEM", "RelativeElevation", "Slope", "Curvature",
#                  "Aspect", "TRI", "TWI")
# topo <- projectRaster(topo, crs = crs)
# env <- data.frame(cbind(env@data, raster::extract(topo, env)))
# rm(topo)
# save(env, file = "./functional_save/env.Rdata")
load("./functional_save/env.Rdata")
```

```{r data}
data <- traits %>%
  mutate(Dawkins = as.numeric(substr(Dawkins, 1,1))) %>% 
  left_join(dplyr::filter(trees, CensusYear == 2015)) %>%
  left_join(env) %>% 
  dplyr::filter(!is.na(SLA)) %>% 
  group_by(Bark, idTree) %>% 
  summarise_if(is.numeric, mean, na.rm =T) %>% 
  ungroup() %>% 
  mutate(DBH = DBH/max(DBH)) %>% 
  mutate(DEM = DEM/max(DEM)) %>% 
  mutate(TWI = TWI/max(TWI))
```

# Introduction

First model for SLA variation in relation to environment.

# SLA - DBH

## Relation

```{r SLADBH}
data %>% 
  ggplot(aes(DBH, SLA, col = Bark, group = NA)) +
  geom_point() +
  geom_smooth()
```

## Michealis Menten model

We will used an inverted Michealis Menten equation for DBH effect on SLA.

$$SLA \sim \mathcal{N} (\frac{dbh + \beta}{\alpha * dbh}, \sigma) $$

```{stan Mdbh, output.var="Mdbh", echo=T, eval=F}
  data {
    int N ; // # obs
    real SLA[N] ;
    real DBH[N] ;
  }
  parameters {
    real<lower=0> alpha ;
    real<lower=0> beta ;
    real<lower=0> sigma ;
  }
  model {
    for(n in 1:N)
      SLA[n] ~ normal((DBH[n] + beta)/(alpha*DBH[n]), sigma) ;
  }
  generated quantities {
    real SLApred[N] ;
    for(n in 1:N)
      SLApred[n] = (DBH[n] + beta)/(alpha*DBH[n]) ;
  }
```

```{r fitMdbh}
# fit <- sampling(Mdbh, chains = 2,
#                 data = list(N = nrow(data),
#                             SLA = data$SLA,
#                             DBH = data$DBH))
# save(fit, file = "./functional_save/Mdbh.Rdata")
load("./functional_save/Mdbh.Rdata")
pars <- c("alpha", "beta", "sigma")
broom::tidyMCMC(fit, pars = c(pars, "lp__"), droppars = NULL, rhat = T) %>% 
  kable(caption = "Summary table of the model dbh only")
```

```{r Cdbh, fig.cap="Model parameters posterior for model dbh only."}
mcmc_intervals(as.array(fit), pars = pars)
```

```{r Tdbh, fig.cap="Markov chains trace plot after warmup for model dbh only"}
mcmc_trace(as.array(fit), pars = c(pars, "lp__"),
           facet_args = list(labeller = label_parsed))
```

```{r 2dbh, fig.cap="Markov chains pairs plot after warmup for model dbh only"}
mcmc_pairs(as.array(fit), pars = c(pars, "lp__"))
```

```{r Ydbh, fig.cap="Predictions for model dbh only"}
cbind(
  data,
  pred = apply(as.matrix(fit, pars = "SLApred"), 2, mean),
  t(apply(as.matrix(fit, pars = "SLApred"), 2, quantile, probs = c(0.05, 0.95)))
) %>% 
  ggplot(aes(x = DBH)) +
  geom_point(aes(y = SLA)) +
  geom_line(aes(y = pred), col = "red") +
  geom_ribbon(aes(ymin = `5%`, ymax = `95%`), color = 'red', alpha = 0.2) +
  geom_line(aes(y = `5%`), col = "red", alpha = 1, size = 0.5, linetype = "dashed") +
  geom_line(aes(y = `95%`), col = "red", alpha = 1, size = 0.5, linetype = "dashed")
```

## Linear model

We will used a linear equation for DBH effect on SLA.

$$SLA \sim \mathcal{N} (\alpha + \beta* dbh, \sigma) $$

```{stan MdbhLinear, output.var="MdbhLinear", echo=T, eval=F}
  data {
    int N ; // # obs
    real SLA[N] ;
    real DBH[N] ;
  }
  parameters {
    real alpha ;
    real beta ;
    real<lower=0> sigma ;
  }
  model {
    for(n in 1:N)
      SLA[n] ~ normal(alpha + beta*DBH[n], sigma) ;
  }
  generated quantities {
    real SLApred[N] ;
    for(n in 1:N)
      SLApred[n] = alpha + beta*DBH[n] ;
  }
```

```{r fitMdbhLinear}
# fit <- sampling(MdbhLinear, chains = 2,
#                 data = list(N = nrow(data),
#                             SLA = data$SLA,
#                             DBH = data$DBH))
# save(fit, file = "./functional_save/MdbhLinear.Rdata")
load("./functional_save/MdbhLinear.Rdata")
pars <- c("alpha", "beta", "sigma")
broom::tidyMCMC(fit, pars = c(pars, "lp__"), droppars = NULL, rhat = T) %>% 
  kable(caption = "Summary table of the model dbh only")
```

```{r CdbhLinear, fig.cap="Model parameters posterior for model dbh only."}
mcmc_intervals(as.array(fit), pars = pars)
```

```{r TdbhLinear, fig.cap="Markov chains trace plot after warmup for model dbh only"}
mcmc_trace(as.array(fit), pars = c(pars, "lp__"),
           facet_args = list(labeller = label_parsed))
```

```{r 2dbhLinear, fig.cap="Markov chains pairs plot after warmup for model dbh only"}
mcmc_pairs(as.array(fit), pars = c(pars, "lp__"))
```

```{r YdbhLinear, fig.cap="Predictions for model dbh only"}
cbind(
  data,
  pred = apply(as.matrix(fit, pars = "SLApred"), 2, mean),
  t(apply(as.matrix(fit, pars = "SLApred"), 2, quantile, probs = c(0.05, 0.95)))
) %>% 
  ggplot(aes(x = DBH)) +
  geom_point(aes(y = SLA)) +
  geom_line(aes(y = pred), col = "red") +
  geom_ribbon(aes(ymin = `5%`, ymax = `95%`), color = 'red', alpha = 0.2) +
  geom_line(aes(y = `5%`), col = "red", alpha = 1, size = 0.5, linetype = "dashed") +
  geom_line(aes(y = `95%`), col = "red", alpha = 1, size = 0.5, linetype = "dashed")
```

In conclusion the likelihood is better for the Michaelis Menten form that we will use in following models.

# SLA - TWI

## Relation

```{r SLATWI}
data %>% 
  ggplot(aes(TWI, SLA, size = DBH, aes = DBH,
             col = Bark)) +
  geom_point()
```

## Linear model

We will used a linear equation for TWI effect on SLA.

$$SLA \sim \mathcal{N} (\alpha + \beta* TWI, \sigma) $$

```{stan MTWI, output.var="MTWI", echo=T, eval=F}
  data {
    int N ; // # obs
    real SLA[N] ;
    real TWI[N] ;
  }
  parameters {
    real alpha ;
    real beta ;
    real<lower=0> sigma ;
  }
  model {
    for(n in 1:N)
      SLA[n] ~ normal(alpha + beta*TWI[n], sigma) ;
  }
  generated quantities {
    real SLApred[N] ;
    for(n in 1:N)
      SLApred[n] = alpha + beta*TWI[n] ;
  }
```

```{r fitMTWILinear}
# fit <- sampling(MTWI, chains = 2,
#                 data = list(N = nrow(data),
#                             SLA = data$SLA,
#                             TWI = data$TWI))
# save(fit, file = "./functional_save/MTWILinear.Rdata")
load("./functional_save/MTWILinear.Rdata")
pars <- c("alpha", "beta", "sigma")
broom::tidyMCMC(fit, pars = c(pars, "lp__"), droppars = NULL, rhat = T) %>% 
  kable(caption = "Summary table of the model v only")
```

```{r CTWILinear, fig.cap="Model parameters posterior for model TWI only."}
mcmc_intervals(as.array(fit), pars = pars)
```

```{r TTWILinear, fig.cap="Markov chains trace plot after warmup for model TWI only"}
mcmc_trace(as.array(fit), pars = c(pars, "lp__"),
           facet_args = list(labeller = label_parsed))
```

```{r 2TWILinear, fig.cap="Markov chains pairs plot after warmup for model TWI only"}
mcmc_pairs(as.array(fit), pars = c(pars, "lp__"))
```

```{r YTWILinear, fig.cap="Predictions for model TWI only"}
cbind(
  data,
  pred = apply(as.matrix(fit, pars = "SLApred"), 2, mean),
  t(apply(as.matrix(fit, pars = "SLApred"), 2, quantile, probs = c(0.05, 0.95)))
) %>% 
  ggplot(aes(x = TWI)) +
  geom_point(aes(y = SLA)) +
  geom_line(aes(y = pred), col = "red") +
  geom_ribbon(aes(ymin = `5%`, ymax = `95%`), color = 'red', alpha = 0.2) +
  geom_line(aes(y = `5%`), col = "red", alpha = 1, size = 0.5, linetype = "dashed") +
  geom_line(aes(y = `95%`), col = "red", alpha = 1, size = 0.5, linetype = "dashed")
```

Topographic wetness index as no effect on SLA.

# SLA - Elevation

## Relation

```{r SLAElevation}
data %>% 
  ggplot(aes(DEM, SLA, size = DBH, aes = DBH,
             col = Bark, group = NA)) +
  geom_point()
```

## Linear model

We will used a linear equation for elevation effect on SLA.

$$SLA \sim \mathcal{N} (\alpha + \beta* Elevation, \sigma) $$

```{stan MElevation, output.var="MElevation", echo=T, eval=F}
  data {
    int N ; // # obs
    real SLA[N] ;
    real Elevation[N] ;
  }
  parameters {
    real alpha ;
    real beta ;
    real<lower=0> sigma ;
  }
  model {
    for(n in 1:N)
      SLA[n] ~ normal(alpha + beta*Elevation[n], sigma) ;
  }
  generated quantities {
    real SLApred[N] ;
    for(n in 1:N)
      SLApred[n] = alpha + beta*Elevation[n] ;
  }
```

```{r fitMElevation}
# fit <- sampling(MElevation, chains = 2,
#                 data = list(N = nrow(data),
#                             SLA = data$SLA,
#                             Elevation = data$DEM))
# save(fit, file = "./functional_save/MElevation.Rdata")
load("./functional_save/MElevation.Rdata")
pars <- c("alpha", "beta", "sigma")
broom::tidyMCMC(fit, pars = c(pars, "lp__"), droppars = NULL, rhat = T) %>% 
  kable(caption = "Summary table of the model Elevation only")
```

```{r CElevationLinear, fig.cap="Model parameters posterior for model Elevation only."}
mcmc_intervals(as.array(fit), pars = pars)
```

```{r TElevationLinear, fig.cap="Markov chains trace plot after warmup for model Elevation only"}
mcmc_trace(as.array(fit), pars = c(pars, "lp__"),
           facet_args = list(labeller = label_parsed))
```

```{r 2ElevationLinear, fig.cap="Markov chains pairs plot after warmup for model Elevation only"}
mcmc_pairs(as.array(fit), pars = c(pars, "lp__"))
```

```{r YElevationLinear, fig.cap="Predictions for model Elevation only"}
cbind(
  data,
  pred = apply(as.matrix(fit, pars = "SLApred"), 2, mean),
  t(apply(as.matrix(fit, pars = "SLApred"), 2, quantile, probs = c(0.05, 0.95)))
) %>% 
  ggplot(aes(x = DEM)) +
  geom_point(aes(y = SLA)) +
  geom_line(aes(y = pred), col = "red") +
  geom_ribbon(aes(ymin = `5%`, ymax = `95%`), color = 'red', alpha = 0.2) +
  geom_line(aes(y = `5%`), col = "red", alpha = 1, size = 0.5, linetype = "dashed") +
  geom_line(aes(y = `95%`), col = "red", alpha = 1, size = 0.5, linetype = "dashed")
```

Elevation as a slight, almost null, positive effect on SLA.

# SLA - Competition

```{r dataCompetition}
# cl <- makeCluster(4)
# clusterExport(cl, list("data", "path"))
# Competition <- clusterMap(cl,
#   function(id, plot, x, y){
#   library(dplyr)
#   src_sqlite(file.path(path, "trees/Paracou.sqlite")) %>%
#     tbl("Paracou") %>%
#     filter(CensusYear == 2005) %>%
#     filter(Plot == plot) %>% 
#     filter(idTree != id) %>% 
#     mutate(DBH = CircCorr*pi) %>%
#     mutate(dij = sqrt((x - Xutm)^2+(y - Yutm)^2)) %>%
#     filter(dij < 20) %>%
#     mutate(idTreej = idTree) %>%
#     mutate(idTreei = id) %>%
#     dplyr::select(idTreei, idTreej, DBH, dij) %>%
#     collect()},
#   id = data$idTree,
#   plot = data$Plot,
#   x = data$Xutm,
#   y = data$Yutm,
#   SIMPLIFY = F)
# stopCluster(cl)
# rm(cl)
# Competition <- bind_rows(Competition)
# save(Competition, file = "./functional_save/CompetitionMatrix.Rdata")
load("./functional_save/CompetitionMatrix.Rdata")
Competition <- Competition %>% 
  mutate(dij = ifelse(dij < 0.4, 0.4, dij)) # measure precision error troubling NCI fit 
dataP16 <- data %>% 
  filter(Plot == 16)
CompetitionP16 <- Competition %>% 
  filter(idTreei %in% dataP16$idTree)
```

## Relation

```{r SLACompetition}
CompetitionP16 %>% 
  group_by(idTreei) %>% 
  summarise(NCI = sum(DBH*exp(-dij))) %>% 
  left_join(dataP16, by = c("idTreei" = "idTree")) %>% 
  ggplot(aes(NCI, SLA, size = DBH, aes = DBH,
             col = Bark, group = NA)) +
  geom_point() +
  geom_smooth()
```

## Competition model

$$SLA_i \sim \mathcal{N} (\sum _{j<20m} DBH_j^\beta * e^{-\alpha*d_{i,j}} , \sigma) $$

```{stan Mcomp, output.var="Mcomp", echo=T, eval=F}
  data {
    int N ; // # obs
    int J ; // # neighbours
    real SLA[N] ;
    real DBH[J] ;
    real dij[J] ;
    int individual[J] ;
  }
  parameters {
    real alpha ;
    real beta ;
    real<lower=0, upper=2> alpha_NCI ;
    real<lower=0, upper=3> beta_NCI ;
    real<lower=0> sigma ;
  }
  transformed parameters {
    real NCI[N] ;
    for(n in 1:N)
      NCI[n] = 0 ;
    for(j in 1:J)
      NCI[individual[j]] = NCI[individual[j]] + DBH[j]^beta_NCI*exp(-alpha_NCI*dij[j]) ;
  }
  model {
    for(n in 1:N)
      SLA[n] ~ normal(alpha + beta*NCI[n], sigma/NCI[n]) ;
  }
  generated quantities {
    real SLApred[N] ;
    for(n in 1:N)
      SLApred[n] = alpha + beta*NCI[n] ;
  }
```

```{r fitMcomp}
fit <- sampling(Mcomp, chains = 2,
                data = list(N = nrow(arrange(dataP16, idTree)),
                            J = nrow(arrange(CompetitionP16, idTreei)),
                            SLA = arrange(dataP16, idTree)$SLA,
                            DBH = arrange(CompetitionP16, idTreei)$DBH,
                            dij = arrange(CompetitionP16, idTreei)$dij,
                            individual = as.numeric(as.factor(arrange(CompetitionP16, idTreei)$idTreei))))
save(fit, file = "./functional_save/ModelSLACompetition.Rdata")
load("./functional_save/ModelSLACompetition.Rdata")
pars <- c("alpha_NCI", "beta_NCI", "alpha", "beta", "sigma")
alpha_NCI <- broom::tidyMCMC(fit, pars = "alpha_NCI")$estimate
beta_NCI <- broom::tidyMCMC(fit, pars = "beta_NCI")$estimate
broom::tidyMCMC(fit, pars = c(pars, "lp__"), droppars = NULL, rhat = T) %>% 
  kable(caption = "Summary table of the model competition only")
```

```{r Ccomp, fig.cap="Model parameters posterior for model competition only."}
mcmc_intervals(as.array(fit), pars = pars)
```

```{r Tcomp, fig.cap="Markov chains trace plot after warmup for model competition only"}
mcmc_trace(as.array(fit), pars = c(pars, "lp__"),
           facet_args = list(labeller = label_parsed))
```

```{r 2comp, fig.cap="Markov chains pairs plot after warmup for model competition only"}
mcmc_pairs(as.array(fit), pars = c(pars, "lp__"))
```

```{r Ycomp, fig.cap="Predictions for model competition only"}
cbind(
  CompetitionP16 %>% 
    group_by(idTreei) %>% 
    summarise(NCI = sum(DBH^beta_NCI*exp(-alpha_NCI*dij))) %>% 
    left_join(dataP16, by = c("idTreei" = "idTree")),
  pred = apply(as.matrix(fit, pars = "SLApred"), 2, mean),
  t(apply(as.matrix(fit, pars = "SLApred"), 2, quantile, probs = c(0.05, 0.95)))
) %>% 
  ggplot(aes(x = NCI)) +
  geom_point(aes(y = SLA)) +
  geom_text(aes(y = SLA, label = idTreei)) +
  geom_line(aes(y = pred), col = "red") +
  geom_ribbon(aes(ymin = `5%`, ymax = `95%`), color = 'red', alpha = 0.2) +
  geom_line(aes(y = `5%`), col = "red", alpha = 1, size = 0.5, linetype = "dashed") +
  geom_line(aes(y = `95%`), col = "red", alpha = 1, size = 0.5, linetype = "dashed")
```

# SLA - Gaps

## Relation

```{r SLAGaps}
gaps <- shapefile(file.path(path, "topography", "Gaps", "gaps4.shp"))

```

## Disturbance model

$$SLA_i \sim \mathcal{N} (\sum _{j<20m} S_j^\beta * e^{-\alpha*d_{i,j}} , \sigma) $$

# SLA - All

## Relation

```{r SLAAll}
Competition %>% 
  group_by(idTreei) %>% 
  summarise(NCI = sum(DBH*exp(-dij))) %>% 
  left_join(data, by = c("idTreei" = "idTree")) %>% 
  dplyr::select(Bark, SLA, DBH, TWI, NCI) %>%
  mutate(DBH0 = DBH) %>% 
  reshape2::melt(id.vars = c("Bark", "SLA", "DBH0")) %>% 
  ggplot(aes(value, SLA, size = DBH0, aes = DBH0,
             col = Bark, group = NA)) +
  geom_point() +
  facet_wrap(~ variable, scales = "free", nrow = 2) +
  geom_smooth()
```

## Full model

$$SLA \sim \mathcal{N} (\frac{dbh + \beta_{DBH}}{\alpha_{DBH} * dbh} +  \beta_{TWI}*TWI + \beta_{Competition}*\sum _{j<20m} DBH_j^{\beta_{NCI}} * e^{-\alpha_{NCI}*d_{i,j}}), \sigma) $$

```{stan Mall, output.var="Mall", echo=T, eval=F}
  data {
    int N ; // # obs
    real SLA[N] ;
    real DBH[N] ;
    real TWI[N] ;
    int J ; // # neighbours
    real DBHj[J] ;
    real dij[J] ;
    int individual[J] ;
  }
  parameters {
    real<lower=0> alpha_DBH ;
    real<lower=0> beta_DBH ;
    real beta_TWI ;
    real beta_Competition ;
    real<lower=0.1, upper=10> alpha_NCI ;
    real<lower=0> beta_NCI ;
    real<lower=0> sigma ;
  }
  transformed parameters {
    real NCI[N] ;
    for(n in 1:N)
      NCI[n] = 0 ;
    for(j in 1:J)
      NCI[individual[j]] = NCI[individual[j]] + DBHj[j]^beta_NCI*exp(-alpha_NCI*dij[j]) ;
  }
  model {
    for(n in 1:N)
      SLA[n] ~ normal((DBH[n] + beta_DBH)/(alpha_DBH*DBH[n]) + beta_TWI*TWI[n] + beta_Competition*NCI[n], sigma) ;
  }
  generated quantities {
    real SLApred[N] ;
    for(n in 1:N)
      SLApred[n] = (DBH[n] + beta_DBH)/(alpha_DBH*DBH[n]) + beta_TWI*TWI[n] + beta_Competition*NCI[n] ;
  }
```

```{r fitMall}
# fit <- sampling(Mall, chains = 2,
#                 data = list(N = nrow(arrange(data, idTree)),
#                             SLA = arrange(data, idTree)$SLA,
#                             DBH = arrange(data, idTree)$DBH,
#                             TWI = arrange(data, idTree)$TWI,
#                             J = nrow(arrange(Competition, idTreei)),
#                             SLA = arrange(data, idTree)$SLA,
#                             DBHj = arrange(Competition, idTreei)$DBH,
#                             dij = arrange(Competition, idTreei)$dij,
#                             individual = as.numeric(as.factor(arrange(Competition, idTreei)$idTreei))))
# save(fit, file = "./functional_save/Mall.Rdata")
load("./functional_save/Mall.Rdata")
pars <- c("alpha_DBH", "beta_DBH", "beta_TWI", "beta_Competition",
          "alpha_NCI", "beta_NCI", "sigma")
alpha_NCI <- broom::tidyMCMC(fit, pars = "alpha_NCI")$estimate
beta_NCI <- broom::tidyMCMC(fit, pars = "beta_NCI")$estimate
broom::tidyMCMC(fit, pars = c(pars, "lp__"), droppars = NULL, rhat = T) %>% 
  kable(caption = "Summary table of the model dbh only")
```

```{r Call, fig.cap="Model parameters posterior for full model."}
mcmc_intervals(as.array(fit), pars = pars)
```

```{r Tall, fig.cap="Markov chains trace plot after warmup for full model"}
mcmc_trace(as.array(fit), pars = c(pars, "lp__"),
           facet_args = list(labeller = label_parsed))
```

```{r 2all, fig.cap="Markov chains pairs plot after warmup for full model"}
mcmc_pairs(as.array(fit), pars = c(pars, "lp__"))
```

```{r Yall, fig.cap="Predictions for full model"}
cbind(
  Competition %>% 
    group_by(idTreei) %>% 
    summarise(NCI = sum(DBH^beta_NCI*exp(-alpha_NCI*dij))) %>% 
    left_join(data, by = c("idTreei" = "idTree")) %>% 
    dplyr::select(Bark, SLA, DBH, TWI, NCI) %>%
    mutate(DBH0 = DBH) %>% 
    reshape2::melt(id.vars = c("Bark", "SLA", "DBH0")),
  pred = apply(as.matrix(fit, pars = "SLApred"), 2, mean),
  t(apply(as.matrix(fit, pars = "SLApred"), 2, quantile, probs = c(0.05, 0.95)))
) %>% 
   ggplot(aes(value, group = NA)) +
  geom_point(aes(y = SLA, size = DBH0, aes = DBH0, col = Bark)) +
  geom_line(aes(y = pred), col = "red") +
  geom_ribbon(aes(ymin = `5%`, ymax = `95%`), color = 'red', alpha = 0.2) +
  geom_line(aes(y = `5%`), col = "red", alpha = 1, size = 0.5, linetype = "dashed") +
  geom_line(aes(y = `95%`), col = "red", alpha = 1, size = 0.5, linetype = "dashed") +
  facet_wrap(~ variable, nrow = 2, scales = "free")
```

# Discussion

# References
