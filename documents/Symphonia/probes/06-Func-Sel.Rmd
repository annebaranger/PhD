---
output:
  pdf_document: default
  html_document: default
---
```{r setup_func_sel, include=FALSE}
rm(list = ls()) ; invisible(gc()) ; set.seed(42)
library(knitr)
library(parallel)
library(Biostrings)
library(tidyverse)
library(kableExtra)
theme_set(bayesplot::theme_default())
opts_chunk$set(
  echo = F, message = F, warning = F, fig.height = 6, fig.width = 8,
  cache = T, cache.lazy = F)
path <- "~/Documents/BIOGECO/PhD/data/Symphonia_Genomes/"
```

# Fuctional region selection

We finally selected 1.067 Mb of sequences by sampling XXXX 0.5-kb to 1-kb sequences within 1 genes (with possible introns) among 1.067 scaffolds (1 gene per scaffold). In order to do that we used successive filters based on: (i) Open Reading Frames (ORF) including start codon (methyonin, M), (ii) non-overlapping genes with overlaped ORFs, (iii) differential expression (a third of non differentially expressed genes and the two remaining third for each over-expressed in each morphotype), and (iv) included SNPs (synonymy and morphotype-specific).

## Transcript alignment on genomics scaffolds

We aligned transcripts from Tysklind et al. (in prep) over filtered and merged genomic scaffolds from and Scotti *et al (in prep)* and @Olsson2017. We obtained 712 278 alignment representing 57 214 genomic scaffolds of 105 Mbp.

```{bash trscAlign, eval=F, echo=T}
#!/bin/bash
#SBATCH --time=36:00:00
#SBATCH -J trscAlign
#SBATCH -o trscAlign_output.out
#SBATCH -e trscAlign_error.out
#SBATCH --mem=20G
#SBATCH --cpus-per-task=1
#SBATCH --mail-type=BEGIN,END,FAIL

# Environment
module purge
module load bioinfo/blatSuite.36

# Alignment
cd ~/work/Symphonia_Genomes/functional_selection
reference=~/work/Symphonia_Genomes/neutral_selection/merged.fasta
query=~/work/Symphonia_Niklas/filtered_transcripts.fasta
blat $reference $query alignment.psl
```

```{r blatRes}
alignment <- read_tsv(file.path(path, "functional_selection", "alignment.psl"), skip = 4, 
         col_names = c("matches", "misMatches", "repMatches", "nCount", 
                       "qNumInsert", "qBaseInsert",
                       "tNumInsert", "tBaseInsert", "strand", 
                       "qName", "qSize", "qStart", "qEnd", 
                       "tName", "tSize", "tStart", "tEnd", 
                       "blockCount", "blockSizes", "qStarts", "tStarts")) %>% # psl3 generics
  rename(trsc = qName, trscSize = qSize, trscStart = qStart, trscEnd = qEnd, 
         scf = tName, scfSize = tSize, scfStart = tStart, scfEnd = tEnd) %>% 
  mutate(alnSize = matches + misMatches + repMatches) %>% 
  select(alnSize,
         trsc, trscSize, trscStart, trscEnd,
         scf, scfSize, scfStart, scfEnd)
```

```{r  blatCov}
total_length <- sum(width(readDNAStringSet(file.path(path, "neutral_selection", "merged.fasta"))))
n_total <- length(readDNAStringSet(file.path(path, "neutral_selection", "merged.fasta")))
data.frame(name = c("aligned sequence", "selected scaffold", "total"),
           n = c(nrow(alignment), length(unique(alignment$scf)), n_total),
           width = c(sum(alignment$alnSize), 
                     sum(unique(select(alignment, scf, scfSize))$scfSize), 
                     total_length)) %>% 
  mutate(coverage = width/total_length*100) %>% 
  mutate(width = width / 10^6) %>% 
  kable(caption = "Alignment coverage of  Tysklind et al. (in prep) transcript over genomic scaffolds with blat.",
        col.names = c("", "N", "Width (Mbp)", "Coverage (%)"),
        format.args = list(big.mark = " "))
```

```{r blatFig, fig.cap="Alignment result of Tysklind et al. (in prep) transcript over genomic scaffolds with blat. Left graph represents the overlap distribution. Right graph represent the selected and deduplicated scaffolds distribution."}
g1 <- ggplot(alignment, aes(alnSize)) +
  geom_histogram() +
  scale_x_log10() +
  xlab("Overlap length of selected transcript\n(from Tysklind et al. (in prep) over genomic scaffolds") +
  coord_flip()
scf <- readDNAStringSet(file.path(path, "Ivan_2018", "transcript_alignment", "unique_selected_scaffolds.fa"))
g2 <- alignment %>% 
  select(scf, scfSize) %>% 
  unique() %>% 
  ggplot(aes(scfSize)) +
  geom_histogram() +
  scale_x_log10() +
  xlab("Selected scaffolds width (bp)") +
  coord_flip()
cowplot::plot_grid(g1, g2)
```

## Transcript filtering with Open Reading Frames (ORFs)

Most of open reading frames included a start codon (methyonin, M) and a stop codon (*, figure \@ref(fig:orfFilterGraph)). We removed ORFs without a start codon for further improved annotation of captured sequences. In addition, the majority of overlapping ORFs were related to the same gene (figure \@ref(fig:orfDist)), but we removed remaining overlapping genes. We used the following formula to get the position of the ORF on the scaffold knowing its position on the transcript:

$$START(ORF|SCF) = START(SCF)+[START(ORF|TRSC)-START(TRSC)]$$
$$END(ORF|SCF) = END(SCF)-[END(TRSC)-END(ORF|TRSC)]$$

```{r orfFilterGraph, fig.cap="Open Reading Frames left and right peptides."}
src_sqlite(file.path("~/Documents/BIOGECO/PhD/data/Symphonia_Niklas/Trinotate/",
                           "symphonia.trinity500.trinotate.sqlite")) %>% 
  tbl("ORF") %>% 
  dplyr::rename(orf = orf_id, trsc = transcript_id, width = length) %>% 
  collect() %>% 
  mutate(left = substr(peptide, 1, 1)) %>% 
  mutate(right = substr(peptide, nchar(peptide), nchar(peptide))) %>% 
  select(orf, strand, left, right) %>% 
  reshape2::melt(id.vars = c("orf", "strand"),
                 variable.name = "side",
                 value.name = "peptide") %>% 
  ggplot(aes(peptide, fill = (peptide %in% c("M", "*")))) +
  geom_bar() +
  facet_grid(strand~side, labeller = "label_both") +
  scale_fill_discrete(guide = F)
```

```{r orfFilterBed, echo=T}
trsc <- readDNAStringSet("~/Documents/BIOGECO/PhD/data/Symphonia_Niklas/filtered_transcripts.fasta")
orf <- src_sqlite(file.path("~/Documents/BIOGECO/PhD/data/Symphonia_Niklas/Trinotate/",
                           "symphonia.trinity500.trinotate.sqlite")) %>% 
  tbl("ORF") %>% 
  dplyr::rename(orf = orf_id, trsc = transcript_id,
                orfSize = length, orfStart = lend, orfEnd = rend) %>% 
  filter(substr(peptide, 1, 1) == "M") %>% 
  select(-peptide, -strand) %>% 
  mutate(orfStart = as.numeric(orfStart),
         orfEnd = as.numeric(orfEnd)) %>% 
  collect()

alignment <- alignment %>% 
  left_join(orf) %>% 
  filter(!is.na(orf)) %>% 
  mutate(gene = gsub("_i[0-9]", "", trsc)) %>% 
  filter(orfStart > trscStart) %>% # rm orf outside of aln
  filter(orfEnd < trscEnd) %>% # rm orf outside of aln
  mutate(orfStart = scfStart+(orfStart-trscStart)) %>% 
  mutate(orfEnd = scfEnd-(trscEnd-orfEnd)) %>% 
  filter(orfEnd > 0)

alignment %>% 
  select(scf, orfStart, orfEnd, orf, gene) %>% 
  group_by(scf, orf) %>% 
  mutate(start = min(orfStart, orfEnd)) %>% 
  mutate(stop = max(orfStart, orfEnd)) %>% 
  ungroup() %>% 
  select(scf, start, stop, orf, gene) %>% 
  arrange(scf, start, stop) %>% 
  write_tsv(path = file.path(path, "functional_selection", "orf.all.bed"),
            col_names = F)
```

```{bash orfBedMerged, eval=F, echo=T}
cd ~/Documents/BIOGECO/PhD/data/Symphonia_Genomes/functional_selection
cat orf.all.bed | sort -k 1,1 -k2,2n >  orf.all.sorted.bed
bedtools merge -i orf.all.sorted.bed -c 5 -o collapse > orf.merged.bed
```

```{r orfDist, fig.cap="Genes overlap", fig.height=4}
read_tsv(file.path(path, "functional_selection", "orf.merged.bed"), 
                col_names = c("scf",  "start",  "end",  "gene")) %>% 
  separate_rows(gene, sep = ",") %>% 
  unique() %>% 
  group_by(scf, start, end) %>% 
  summarise(genes = n())  %>% 
  ggplot(aes(genes, fill = (genes == 1))) + 
  geom_histogram(binwidth = 1) +
  xlab("Number of overlapping genes\n(1 = no overlap)") +
  xlim(0, 12) +
  scale_fill_discrete(guide = F)
```

## Genes detection woth Open Reading Frames (ORFs)

We calculated genes size, exon count, intron percentage, exon total width, by scaffold width summarized in figure \@ref(fig:genesPlot). We have a total of 12 446 genes.

```{r genesFilter1, echo=T}
# scf
scf <- readDNAStringSet(file.path(path, "neutral_selection", "merged.fasta"))
# orfs
orf <- read_tsv(file.path(path, "functional_selection", "orf.merged.bed"), 
                col_names = c("scf",  "start",  "end",  "gene")) %>% 
  separate_rows(gene, sep = ",") %>% 
  unique() %>% 
  group_by(scf, start, end) %>% 
  filter(n() == 1) %>% 
  ungroup()
# genes
genes <- data.frame(scf = names(scf), width_scf = width(scf), 
                        N = letterFrequency(scf, "N")) %>% 
  left_join(orf) %>% 
  filter(!is.na(gene)) %>% 
  mutate(width_exon = end-start) %>% 
  group_by(scf, start, end) %>%
  filter(n() == 1) %>% 
  group_by(scf, width_scf, gene) %>% 
  summarise(start = min(start), end = max(end), width_exons = sum(width_exon)) %>% 
  mutate(width_gene = end - start) %>% 
  mutate(perc_intron = (1-(width_exons/width_gene))*100) %>% 
  ungroup()
```

```{r genesPlot, fig.cap="Available genes for target sequences design."}
genes %>% 
  ggplot(aes(width_scf/1000, width_gene, col = perc_intron)) + 
  geom_hline(yintercept = 1000, col = "red", lwd = 1) +
  geom_point(alpha = 0.5) +
  xlab("Scaffold width (kbp)") +
  ylab("Gene width (kbp)") +
  scale_y_log10() +
  scale_color_continuous("Intron\npercentage") +
  ggtitle(paste(nrow(genes), "genes"), 
          paste(format(sum(genes$width_gene)/1000, big.mark = " "), "kbp"))
```

## Differential Expression (DE) of genes

**Should introduce a Vienn-Diagramm here !**

```{r diffExprTab}
read_delim(file.path(path, "..", "Symphonia_Niklas", "edgeR",
                     "juv_sympho_43k_retained_genes_DecisionTest.txt"), 
           delim = " ") %>% 
  select(-X) %>% 
  rename(trsc = genes, deg = X.0.5.glo_HT..0.5.glo_SF.0.5.sp1_HT.0.5.sp1_SF) %>%
  mutate(deg = ifelse(deg == 1, "Eglo", deg)) %>% 
  mutate(deg = ifelse(deg == -1, "Esp", deg)) %>% 
  mutate(deg = ifelse(deg == 0, "NE", deg)) %>% 
  mutate(gene = gsub("_i[0-9]", "", trsc)) %>% 
  filter(gene %in% genes$gene) %>% 
  select(gene, deg) %>% 
  unique() %>% 
  count(gene, deg) %>% 
  tidyr::spread(deg, n, fill=0) %>% 
  mutate(NE, NE = recode(NE, "1"="Not enriched")) %>% 
  mutate(Eglo, Eglo = recode(Eglo, "1"="Globulifera enriched")) %>% 
  mutate(Esp, Esp = recode(Esp, "1"="Sp1 enriched")) %>% 
  mutate(deg = paste(NE, Esp, Eglo, sep = "-")) %>% 
  count(deg) %>% 
  select(deg, n) %>% 
  sunburstR::sunburst(count = T)
```

## Single Nulcotide Polyphormisms (SNPs) of genes

We found back 230 109 SNPs (29%) in the first 1kbp of genes pre-selected for target sequences (figure \@ref(fig:SNPin1kbpgene)). 

```{r SNPcandidateSequences, echo=T}
snp <- read_delim(file.path("~/Documents/BIOGECO/PhD/data/Symphonia_Niklas/k2rt", "symphonia_juv_fullsample_trinity500_k2rt_type_0a_mainOutput.tsv"),
           delim = "\t") %>% 
  filter(Possible_sequencing_error != "True") %>% 
  filter(SNP_in_mutliple_assembled_genes != "True") %>% 
  filter((Is_in_CDS == "False" & Is_not_synonymous == "N/A") | 
           (Is_in_CDS == "True" & Is_not_synonymous == "False") |
           (Is_in_CDS == "True" & Is_not_synonymous == "True")) %>% 
  dplyr::rename(trsc = `#Component_ID`, snp = SNP_ID,
         position = SNP_position,
         synonymy = Is_not_synonymous,
         mtSpec = Is_condition_specific) %>% 
  mutate(synonymy = ifelse(synonymy == "False", "synonym", synonymy)) %>% 
  mutate(synonymy = ifelse(synonymy == "True", "non-synonym", synonymy)) %>% 
  mutate(mtSpec = ifelse(mtSpec == "False", "non-specific", mtSpec)) %>% 
  mutate(mtSpec = ifelse(mtSpec == "True", "mt-specific", mtSpec)) %>% 
  mutate(gene = gsub("_i[0-9]", "", trsc)) %>% 
  select(gene, trsc, snp, position, synonymy, mtSpec)
```

```{r SNPin1kbpgene, fig.cap="SNPs included in the first 1 kbp of the gene."}
genes %>% 
  left_join(snp) %>% 
  mutate(snp_in_1kbp_start_gene = (position < start + 1001)) %>% 
  ggplot(aes(snp_in_1kbp_start_gene)) + 
  geom_bar() +
  xlab("SNPs included in the first 1 kbp of the gene.") +
  ggtitle(paste(format(nrow(left_join(genes, snp)), big.mark = " "), 
                "SNPs within genes"),
          paste(format(unlist(count(left_join(genes, snp), 
                             position < start + 1001)[2,2]), big.mark = " "), 
                "SNPs (",
                round(count(left_join(genes, snp), 
                            position < start + 1001)[2,2]/
                        nrow(left_join(genes, snp))*100),
                "%) SNPs in the first 1kbp"))
```

```{r SNPfilter}
genes_snp <- genes %>% 
  left_join(genes %>% 
              left_join(snp) %>% 
              filter(position < start + 1001)) %>% 
  mutate(snp = ifelse(is.na(mtSpec), 0, 1)) %>% 
  select(gene, snp, synonymy, mtSpec) %>% 
  group_by(gene) %>%
  summarise(snp = (sum(snp) > 0),
            synonymy = paste(sort(unique(synonymy)), collapse = " "),
            mtSpec = paste(sort(unique(mtSpec)), collapse = " ")) %>% 
  mutate(mtSpec = ifelse(mtSpec == "mt-specific non-specific", "both", mtSpec)) %>% 
  mutate(synonymy = ifelse(synonymy %in% c("na-synonym non-synonym synonym", 
                                           "na-synonym non-synonym",
                                          "non-synonym synonym"), "both", synonymy)) %>% 
  mutate(synonymy = ifelse(synonymy %in% c("na-synonym", "synonym", "na-synonym synonym"), 
                                           "na/synonym", synonymy))
```

```{r snpTypeGene}
genes_snp %>% 
  group_by(snp, synonymy, mtSpec) %>% 
  summarise(n = n()) %>% 
  kable(caption = "Type of SNPs per genes.",
        col.names = c("Gene with SNP", "SNP synonymy", 
                      "SNP morphotype-specificity (mtSpec)", "N"),
        format = ifelse(knitr::is_html_output(), "html", "latex"), 
        format.args = list(big.mark = " ")) %>% 
  kable_styling("striped", full_width = F) %>%
  collapse_rows(columns = 1:2)
```

## Final subset of selected functional scaffolds
