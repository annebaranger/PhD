---
title: "A04 : AbioticModel"
# date: '`r Sys.Date()`'
# author: Sylvain Schmitt & Anne Baranger
output: 
  bookdown::html_document2:
    number_sections: false
    toc: true
    toc_float: yes
  flexdashboard::flex_dashboard:
    orientation: columns
    vertical_layout: scroll
# csl: /home/sylvain/Documents/Bibliography/csl/mee.csl
# bibliography: /home/sylvain/Documents/Bibliography/library.bib
link-citations: yes
---

```{r setup, include=FALSE}
# rm(list = ls()) ; invisible(gc()) ; set.seed(42)
library(knitr)
library(tidyverse)
library(kableExtra)
library(rstan)
library(bayesplot)
theme_set(bayesplot::theme_default())
opts_chunk$set(
  echo = F, message = F, warning = F, fig.height = 6, fig.width = 6,
  cache = T, cache.lazy = F)
options(mc.cores = parallel::detectCores())
rstan_options(auto_write = T)
path <- "../../data/Paracou/"
```

# Data
```{r data, eval=T}
traitsSymphonia <- googlesheets::gs_title("Measures_Symphonia") %>% 
  googlesheets::gs_read("AllTraits") %>% 
  mutate(SLA = as.numeric(SLA), LDMC = as.numeric(LDMC)) %>% 
  mutate(Genus = "Symphonia") %>% 
  rename(Species = Morphotype)
traitsEschweilera <- googlesheets::gs_title("Measures_Eschweilera") %>% 
  googlesheets::gs_read("AllTraits")
traits <- bind_rows(traitsEschweilera, traitsSymphonia) %>% 
  mutate(SpeciesLong = paste(substr(Genus, 1, 1), Species)) ; rm(traitsEschweilera, traitsSymphonia)
paracou <- src_sqlite(file.path(path, "trees", "Paracou.sqlite")) %>%
  tbl("Paracou") %>%
  filter(idTree %in% traits$idTree) %>%
  filter(Genus %in% c("Lecythis", "Eschweilera") & Plot %in% c(1, 6, 11, 13:15) & CensusYear == 2017 |
         Genus %in% c("Lecythis", "Eschweilera") & Plot == 16 & CensusYear == 2015 |
         Genus == "Symphonia" & CensusYear == 2015) %>%
  mutate(DBH = CircCorr/pi) %>% 
  collect()
load("./functional_save/env.Rdata")
Individuals <- left_join(traits, paracou) %>% 
  filter(!(Plot == 14 & SubPlot == 1 & TreeFieldNum == 760)) %>%  # rejection individual
  filter(!(SpeciesLong %in% c("E congestiflora","E simiorum","L persistens"))) %>% 
  left_join(env, by = "idTree", suffix = c("", ".y")) %>% 
  group_by(Plot, SubPlot, TreeFieldNum, Genus, Species,
           SpeciesLong, Bark, Dawkins, DBH, TWI, Curvature) %>%
  summarise_at(vars("SLA", "LDMC", "LT", "LA", "CC",
                    "brBT", "brBD", "brWD"), mean, na.rm = T)  %>%
  ungroup()
rm(traits, paracou, env)
```

```{r DataForStan}
traits <- c("SLA","LA","LDMC","CC","LT")
data <- sapply(traits, function(trait)
  list(N = nrow(Individuals[unlist(!is.na(Individuals[trait])),]),
       Trait = unlist(Individuals[unlist(!is.na(Individuals[trait])),trait]),
       TWI = Individuals[unlist(!is.na(Individuals[trait])),]$TWI), simplify = F)
#str(data)
```

# Model without random nested effect

We explained leaf trait $T$ according to abiotic environment following a normal law with a linear model form:

\begin{equation} 
 T_i \sim \mathcal{N}(\alpha_{TWI} + \beta_{TWI}. TWI_i ,\sigma_{TWI})
\\(\alpha_{TWI}, \sigma_{comp}) \sim \Gamma^{2}(- \infty, + \infty)
\\(\beta_{TWI}) \sim \mathcal{N}(0, + \infty)
(\#eq:Competition)
\end{equation}

where:

* $T_i$ is a functional trait of an individual i associated to a $TWI_i$ value ;
* $i \in [1,I]$ where I is the number of individuals;
* $\alpha_{TWI}$ and $\beta_{TWI}$ are linear model parameters. $\alpha_{TWI}$ can range in positive or negative value, and as $\beta_{TWI}$ is the intercept and has to range in positive value as $TWI$. Normal flat law and gamma law were respectively chosen as non informative flat priors on $\mathbb{R}$ and $\mathbb{R}^+$;
* $\sigma_{DBH}$ is normal law standard error, and will, be chosen with positive values. Therefore, a gamma law was chosen as non informative flat prior on $\mathbb{R}^+$.


## Code
```{stan, output.var="Model",echo=T,eval=F}
data {
  int<lower=1>  N; // Number of observations
  vector[N] Trait; // Trait
  vector[N] TWI; // Topographic wetness index
}
parameters {
  real<lower=0> alphaTWI; // intercept
  real betaTWI; // Trait parameter
  real<lower=0> sigmaTWI; // variance
}
model {
  alphaTWI ~ gamma(10^-2, 10^-2); // alpha prior
  betaTWI ~ normal(0, 10^2); // beta prior
  sigmaTWI ~ gamma(10^-2, 10^-2); // sigma prior
  Trait ~ normal(alphaTWI + betaTWI*TWI, sigmaTWI); // Likelihood
} 
generated quantities {
  vector[N] Traitpred ;
  Traitpred = alphaTWI + betaTWI*TWI ;
}// empty line at the end (C++)

```


## Summary

```{r }
# fits <- lapply(data, function(x) sampling(Model, chains = 2, data = x))
# names(fits) <- traits
# save(fits, file = "./functional_save/TWI.Rdata")
load("./functional_save/TWI.Rdata")
pars <- c("alphaTWI","betaTWI","sigmaTWI")
lapply(as.list(traits), function(trait)
  broom::tidyMCMC(fits[[trait]], pars = c(pars, "lp__"), droppars = NULL, rhat = T) %>%
   mutate(Trait = trait)) %>%
  bind_rows() %>%
  kable() %>%
  kable_styling()
```

## Posteriors

```{r , fig.cap="Model parameters posterior."}
cowplot::plot_grid(plotlist = lapply(traits, function(trait)
  mcmc_intervals(as.array(fits[[trait]]), pars = pars)),
  labels = names(data), nrow = 2)
```

## Chains

```{r , fig.cap="Markov chains trace plot after warmup for intermediate data."}
mcmc_trace(as.array(fits$LA), pars = c(pars, "lp__"),
             facet_args = list(labeller = label_parsed))
```

## Pairs

```{r , fig.cap="Markov chains pairs plot after warmup  for intermediate data."}
mcmc_pairs(as.array(fits$CC), pars = pars)
```

## Predictions

```{r , fig.cap="Predictions."}
lapply(as.list(traits), function(trait)
  cbind(fit = trait, 
        Y = unlist(Individuals[unlist(!is.na(Individuals[trait])), trait]),
        Individuals[unlist(!is.na(Individuals[trait])),],
        Traitpred = apply(as.matrix(fits[[trait]], pars = "Traitpred"), 2, mean),
        sigmaTWI = apply(as.matrix(fits[[trait]], pars = "sigmaTWI"), 2, mean),
        mu5 = unlist(apply(as.matrix(fits[[trait]], pars = "Traitpred"), 2, quantile, probs = 0.05)),
        mu95 = unlist(apply(as.matrix(fits[[trait]], pars = "Traitpred"), 2, quantile, probs = 0.95)),
        sigmaTWI95 = unlist(apply(as.matrix(fits[[trait]], pars = "sigmaTWI"), 2, quantile, probs = 0.95))
        )) %>% 
  bind_rows() %>% 
  mutate(Y5sigmafix = qnorm(0.05, mean = mu5, sd = sigmaTWI)) %>% 
  mutate(Y95sigmafix = qnorm(0.95, mean = mu95, sd = sigmaTWI)) %>% 
  mutate(Y5 = qnorm(0.05, mean = mu5, sd = sigmaTWI95)) %>% 
  mutate(Y95 = qnorm(0.95, mean = mu95, sd = sigmaTWI95)) %>% 
  ggplot(aes(x = TWI)) +
  geom_point(aes(y = Y)) +
  geom_line(aes(y = Traitpred)) +
  geom_ribbon(aes(ymin = Y5, ymax = Y95, color = 'Ypred'), alpha = 0.2) +
  geom_ribbon(aes(ymin = Y5sigmafix, ymax = Y95sigmafix, color = 'Ysigmafix'), alpha = 0.2) +
  geom_ribbon(aes(ymin = mu5, ymax = mu95, color = 'mu'), alpha = 0.2) +
  facet_wrap(~ fit, scales = "free", nrow = 3)
```

# Model with random nested effect

```{stan, output.var="Model",echo=T,eval=F}
data {
  int<lower=1>  N; // Number of observations
  vector[N] Trait; // Trait
  vector[N] TWI; // Topographic wetness index
}
parameters {
  real<lower=0> alphaTWI; // intercept
  real betaTWI; // Trait parameter
  real<lower=0> sigmaTWI; // variance
}
model {
  alphaTWI ~ gamma(10^-2, 10^-2); // alpha prior
  betaTWI ~ normal(0, 10^2); // beta prior
  sigmaTWI ~ gamma(10^-2, 10^-2); // sigma prior
  Trait ~ normal(alphaTWI + betaTWI*TWI, sigmaTWI); // Likelihood
} 
generated quantities {
  vector[N] Traitpred ;
  Traitpred = alphaTWI + betaTWI*TWI ;
}// empty line at the end (C++)

```
