---
title: "AO6: CC & Environment"
date: '`r Sys.Date()`'
output:
  bookdown::html_document2:
    number_sections: false
    toc: true
    toc_float: yes
  bookdown::word_document2: default
  github_document: default
  bookdown::pdf_document2:
    includes:
      before_body: ./template/doc_prefix.tex
      in_header: ./template/preamble.tex
    number_sections: false
    toc: false
    keep_tex: true
linestretch: 1.5
csl: /home/sylvain/Documents/Bibliography/csl/mee.csl
bibliography: /home/sylvain/Documents/Bibliography/library.bib
link-citations: yes
---

```{r setup, include=FALSE}
rm(list = ls()) ; invisible(gc()) ; set.seed(42)
library(knitr)
library(parallel)
library(tidyverse)
library(ggfortify)
library(raster)
library(rstan)
library(bayesplot)
theme_set(bayesplot::theme_default())
opts_chunk$set(
  echo = F, message = F, warning = F, fig.height = 6, fig.width = 6,
  cache = T, cache.lazy = F)
options(mc.cores = parallel::detectCores())
rstan_options(auto_write = T)
path <- "~/Documents/BIOGECO/PhD/data/Paracou/"
crs <- '+proj=longlat +datum=NAD83 +no_defs +ellps=GRS80 +towgs84=0,0,0' # global crs definition
```

```{r traits}
traits <- googlesheets::gs_title("Measures") %>% 
  googlesheets::gs_read("AllTraits") %>% 
  mutate(CC = as.numeric(CC), CC = as.numeric(CC))
```

```{r trees}
trees <- src_sqlite(file.path(path, "trees/Paracou.sqlite")) %>% 
  tbl("Paracou") %>% 
  filter(idTree %in% traits$idTree) %>% 
  collect() %>% 
  mutate(DBH = CircCorr*pi)
```

```{r env}
# env <- trees %>%
#   dplyr::select(idTree, Xutm, Yutm) %>%
#   unique()
# coordinates(env) <- ~Xutm + Yutm
# proj4string(env) <- '+proj=utm +zone=22 +datum=WGS84 +units=m +no_defs +ellps=WGS84 +towgs84=0,0,0'
# env <- spTransform(env, CRSobj = crs)
# topo <- stack(
#   raster(file.path(path, "topography", "DEM_1m_2015.tif")),
#   raster(file.path(path, "topography", "RelativeElevation_1m.tif")),
#   raster(file.path(path, "topography", "slope_1m.tif")),
#   raster(file.path(path, "topography", "curvature_1m.tif")),
#   raster(file.path(path, "topography", "aspect_1m.tif")),
#   raster(file.path(path, "topography", "TRI_1m.tif")),
#   raster(file.path(path, "topography", "TWI_1m.tif"))
# )
# names(topo) <- c("DEM", "RelativeElevation", "Slope", "Curvature",
#                  "Aspect", "TRI", "TWI")
# topo <- projectRaster(topo, crs = crs)
# env <- data.frame(cbind(env@data, raster::extract(topo, env)))
# rm(topo)
# save(env, file = "./functional_save/env.Rdata")
load("./functional_save/env.Rdata")
```

```{r data}
data <- traits %>%
  mutate(Dawkins = as.numeric(substr(Dawkins, 1,1))) %>% 
  left_join(dplyr::filter(trees, CensusYear == 2015)) %>%
  left_join(env) %>% 
  dplyr::filter(!is.na(CC)) %>% 
  group_by(Bark, idTree) %>% 
  summarise_if(is.numeric, mean, na.rm =T) %>% 
  ungroup() %>% 
  mutate(DBH = DBH/max(DBH)) %>% 
  mutate(DEM = DEM/max(DEM)) %>% 
  mutate(TWI = TWI/max(TWI))
```

# Introduction

First model for CC variation in relation to environment.

# CC - DBH

## Relation

```{r CCDBH}
data %>% 
  ggplot(aes(DBH, CC, col = Bark, group = NA)) +
  geom_point() +
  geom_smooth()
```

## Michealis Menten model

We will used an inverted Michealis Menten equation for DBH effect on CC.

$$CC \sim \mathcal{N} (\frac{dbh + \beta}{\alpha * dbh}, \sigma) $$

```{stan Mdbh, output.var="Mdbh", echo=T, eval=F}
  data {
    int N ; // # obs
    real CC[N] ;
    real DBH[N] ;
  }
  parameters {
    real<lower=0> alpha ;
    real<lower=0> beta ;
    real<lower=0> sigma ;
  }
  model {
    for(n in 1:N)
      CC[n] ~ normal((alpha*DBH[n])/(DBH[n] + beta), sigma) ;
  }
  generated quantities {
    real CCpred[N] ;
    for(n in 1:N)
      CCpred[n] = (alpha*DBH[n])/(DBH[n] + beta) ;
  }
```

```{r fitMdbh}
# fit <- sampling(Mdbh, chains = 2,
#                 data = list(N = nrow(data),
#                             CC = data$CC,
#                             DBH = data$DBH))
# save(fit, file = "./functional_save/ModelCCdbh.Rdata")
load("./functional_save/ModelCCdbh.Rdata")
pars <- c("alpha", "beta", "sigma")
broom::tidyMCMC(fit, pars = c(pars, "lp__"), droppars = NULL, rhat = T) %>% 
  kable(caption = "Summary table of the model dbh only")
```

```{r Cdbh, fig.cap="Model parameters posterior for model dbh only."}
mcmc_intervals(as.array(fit), pars = pars)
```

```{r Tdbh, fig.cap="Markov chains trace plot after warmup for model dbh only"}
mcmc_trace(as.array(fit), pars = c(pars, "lp__"),
           facet_args = list(labeller = label_parsed))
```

```{r 2dbh, fig.cap="Markov chains pairs plot after warmup for model dbh only"}
mcmc_pairs(as.array(fit), pars = c(pars, "lp__"))
```

```{r Ydbh, fig.cap="Predictions for model dbh only"}
cbind(
  data,
  pred = apply(as.matrix(fit, pars = "CCpred"), 2, mean),
  t(apply(as.matrix(fit, pars = "CCpred"), 2, quantile, probs = c(0.05, 0.95)))
) %>% 
  ggplot(aes(x = DBH)) +
  geom_point(aes(y = CC)) +
  geom_line(aes(y = pred), col = "red") +
  geom_ribbon(aes(ymin = `5%`, ymax = `95%`), color = 'red', alpha = 0.2) +
  geom_line(aes(y = `5%`), col = "red", alpha = 1, size = 0.5, linetype = "dashed") +
  geom_line(aes(y = `95%`), col = "red", alpha = 1, size = 0.5, linetype = "dashed")
```

## Linear model

We will used a linear equation for DBH effect on CC.

$$CC \sim \mathcal{N} (\alpha + \beta* dbh, \sigma) $$

```{stan MdbhLinear, output.var="MdbhLinear", echo=T, eval=F}
  data {
    int N ; // # obs
    real CC[N] ;
    real DBH[N] ;
  }
  parameters {
    real alpha ;
    real beta ;
    real<lower=0> sigma ;
  }
  model {
    for(n in 1:N)
      CC[n] ~ normal(alpha + beta*DBH[n], sigma) ;
  }
  generated quantities {
    real CCpred[N] ;
    for(n in 1:N)
      CCpred[n] = alpha + beta*DBH[n] ;
  }
```

```{r fitMdbhLinear}
# fit <- sampling(MdbhLinear, chains = 2,
#                 data = list(N = nrow(data),
#                             CC = data$CC,
#                             DBH = data$DBH))
# save(fit, file = "./functional_save/ModelCCdbhLinear.Rdata")
load("./functional_save/ModelCCdbhLinear.Rdata")
pars <- c("alpha", "beta", "sigma")
broom::tidyMCMC(fit, pars = c(pars, "lp__"), droppars = NULL, rhat = T) %>% 
  kable(caption = "Summary table of the model dbh only")
```

```{r CdbhLinear, fig.cap="Model parameters posterior for model dbh only."}
mcmc_intervals(as.array(fit), pars = pars)
```

```{r TdbhLinear, fig.cap="Markov chains trace plot after warmup for model dbh only"}
mcmc_trace(as.array(fit), pars = c(pars, "lp__"),
           facet_args = list(labeller = label_parsed))
```

```{r 2dbhLinear, fig.cap="Markov chains pairs plot after warmup for model dbh only"}
mcmc_pairs(as.array(fit), pars = c(pars, "lp__"))
```

```{r YdbhLinear, fig.cap="Predictions for model dbh only"}
cbind(
  data,
  pred = apply(as.matrix(fit, pars = "CCpred"), 2, mean),
  t(apply(as.matrix(fit, pars = "CCpred"), 2, quantile, probs = c(0.05, 0.95)))
) %>% 
  ggplot(aes(x = DBH)) +
  geom_point(aes(y = CC)) +
  geom_line(aes(y = pred), col = "red") +
  geom_ribbon(aes(ymin = `5%`, ymax = `95%`), color = 'red', alpha = 0.2) +
  geom_line(aes(y = `5%`), col = "red", alpha = 1, size = 0.5, linetype = "dashed") +
  geom_line(aes(y = `95%`), col = "red", alpha = 1, size = 0.5, linetype = "dashed")
```

In conclusion the likelihood is better for the Michaelis Menten form that we will use in following models.

# CC - TWI

## Relation

```{r CCTWI}
data %>% 
  ggplot(aes(TWI, CC, size = DBH, aes = DBH,
             col = Bark, group = NA)) +
  geom_point() +
  geom_smooth()
```

## Linear model

We will used a linear equation for TWI effect on CC.

$$CC \sim \mathcal{N} (\alpha + \beta* TWI, \sigma) $$

```{stan MTWI, output.var="MTWI", echo=T, eval=F}
  data {
    int N ; // # obs
    real CC[N] ;
    real TWI[N] ;
  }
  parameters {
    real alpha ;
    real beta ;
    real<lower=0> sigma ;
  }
  model {
    for(n in 1:N)
      CC[n] ~ normal(alpha + beta*TWI[n], sigma) ;
  }
  generated quantities {
    real CCpred[N] ;
    for(n in 1:N)
      CCpred[n] = alpha + beta*TWI[n] ;
  }
```

```{r fitMTWILinear}
# fit <- sampling(MTWI, chains = 2,
#                 data = list(N = nrow(data),
#                             CC = data$CC,
#                             TWI = data$TWI))
# save(fit, file = "./functional_save/ModelCCTWILinear.Rdata")
load("./functional_save/ModelCCTWILinear.Rdata")
pars <- c("alpha", "beta", "sigma")
broom::tidyMCMC(fit, pars = c(pars, "lp__"), droppars = NULL, rhat = T) %>% 
  kable(caption = "Summary table of the model v only")
```

```{r CTWILinear, fig.cap="Model parameters posterior for model TWI only."}
mcmc_intervals(as.array(fit), pars = pars)
```

```{r TTWILinear, fig.cap="Markov chains trace plot after warmup for model TWI only"}
mcmc_trace(as.array(fit), pars = c(pars, "lp__"),
           facet_args = list(labeller = label_parsed))
```

```{r 2TWILinear, fig.cap="Markov chains pairs plot after warmup for model TWI only"}
mcmc_pairs(as.array(fit), pars = c(pars, "lp__"))
```

```{r YTWILinear, fig.cap="Predictions for model TWI only"}
cbind(
  data,
  pred = apply(as.matrix(fit, pars = "CCpred"), 2, mean),
  t(apply(as.matrix(fit, pars = "CCpred"), 2, quantile, probs = c(0.05, 0.95)))
) %>% 
  ggplot(aes(x = TWI)) +
  geom_point(aes(y = CC)) +
  geom_line(aes(y = pred), col = "red") +
  geom_ribbon(aes(ymin = `5%`, ymax = `95%`), color = 'red', alpha = 0.2) +
  geom_line(aes(y = `5%`), col = "red", alpha = 1, size = 0.5, linetype = "dashed") +
  geom_line(aes(y = `95%`), col = "red", alpha = 1, size = 0.5, linetype = "dashed")
```

Topographic wetness index as a significant negative effect on CC.

# CC - Elevation

## Relation

```{r CCElevation}
data %>% 
  ggplot(aes(DEM, CC, size = DBH, aes = DBH,
             col = Bark, group = NA)) +
  geom_point() +
  geom_smooth()
```

Elevation is strongly correlated to TWI and has a smaller likelihood than TWI, so we should only keep TWI as they give the same information.

## Linear model

We will used a linear equation for elevation effect on CC.

$$CC \sim \mathcal{N} (\alpha + \beta* Elevation, \sigma) $$

```{stan MElevation, output.var="MElevation", echo=T, eval=F}
  data {
    int N ; // # obs
    real CC[N] ;
    real Elevation[N] ;
  }
  parameters {
    real alpha ;
    real beta ;
    real<lower=0> sigma ;
  }
  model {
    for(n in 1:N)
      CC[n] ~ normal(alpha + beta*Elevation[n], sigma) ;
  }
  generated quantities {
    real CCpred[N] ;
    for(n in 1:N)
      CCpred[n] = alpha + beta*Elevation[n] ;
  }
```

```{r fitMElevation}
# fit <- sampling(MElevation, chains = 2,
#                 data = list(N = nrow(data),
#                             CC = data$CC,
#                             Elevation = data$DEM))
# save(fit, file = "./functional_save/ModelCCElevation.Rdata")
load("./functional_save/ModelCCElevation.Rdata")
pars <- c("alpha", "beta", "sigma")
broom::tidyMCMC(fit, pars = c(pars, "lp__"), droppars = NULL, rhat = T) %>% 
  kable(caption = "Summary table of the model Elevation only")
```

```{r CElevationLinear, fig.cap="Model parameters posterior for model Elevation only."}
mcmc_intervals(as.array(fit), pars = pars)
```

```{r TElevationLinear, fig.cap="Markov chains trace plot after warmup for model Elevation only"}
mcmc_trace(as.array(fit), pars = c(pars, "lp__"),
           facet_args = list(labeller = label_parsed))
```

```{r 2ElevationLinear, fig.cap="Markov chains pairs plot after warmup for model Elevation only"}
mcmc_pairs(as.array(fit), pars = c(pars, "lp__"))
```

```{r YElevationLinear, fig.cap="Predictions for model Elevation only"}
cbind(
  data,
  pred = apply(as.matrix(fit, pars = "CCpred"), 2, mean),
  t(apply(as.matrix(fit, pars = "CCpred"), 2, quantile, probs = c(0.05, 0.95)))
) %>% 
  ggplot(aes(x = DEM)) +
  geom_point(aes(y = CC)) +
  geom_line(aes(y = pred), col = "red") +
  geom_ribbon(aes(ymin = `5%`, ymax = `95%`), color = 'red', alpha = 0.2) +
  geom_line(aes(y = `5%`), col = "red", alpha = 1, size = 0.5, linetype = "dashed") +
  geom_line(aes(y = `95%`), col = "red", alpha = 1, size = 0.5, linetype = "dashed")
```

Elevation is strongly correlated to TWI and has a smaller likelihood than TWI, so we should only keep TWI as they give the same information.

# CC - Competition

```{r dataCompetition}
# cl <- makeCluster(4)
# clusterExport(cl, list("data", "path"))
# Competition <- clusterMap(cl,
#   function(id, plot, x, y){
#   library(dplyr)
#   src_sqlite(file.path(path, "trees/Paracou.sqlite")) %>%
#     tbl("Paracou") %>%
#     filter(CensusYear == 2005) %>%
#     filter(Plot == plot) %>% 
#     filter(idTree != id) %>% 
#     mutate(DBH = CircCorr*pi) %>%
#     mutate(dij = sqrt((x - Xutm)^2+(y - Yutm)^2)) %>%
#     filter(dij < 20) %>%
#     mutate(idTreej = idTree) %>%
#     mutate(idTreei = id) %>%
#     dplyr::select(idTreei, idTreej, DBH, dij) %>%
#     collect()},
#   id = data$idTree,
#   plot = data$Plot,
#   x = data$Xutm,
#   y = data$Yutm,
#   SIMPLIFY = F)
# stopCluster(cl)
# rm(cl)
# Competition <- bind_rows(Competition)
# Competition <- Competition %>% 
#   mutate(dij = ifelse(dij < 0.4, 0.4, dij)) # measure precision error troubling NCI fit 
# save(Competition, file = "./functional_save/CompetitionMatrix.Rdata")
load("./functional_save/CompetitionMatrix.Rdata")
```

## Relation

```{r CCCompetition}
Competition %>% 
  group_by(idTreei) %>% 
  summarise(NCI = sum(DBH*exp(-dij))) %>% 
  left_join(data, by = c("idTreei" = "idTree")) %>% 
  ggplot(aes(NCI, CC, size = DBH, aes = DBH,
             col = Bark, group = NA)) +
  geom_point() +
  geom_smooth()
```

## Competition model

$$CC_i \sim \mathcal{N} (\sum _{j<20m} DBH_j^\beta * e^{-\alpha*d_{i,j}} , \sigma) $$

```{stan Mcomp, output.var="Mcomp", echo=T, eval=F}
  data {
    int N ; // # obs
    int J ; // # neighbours
    real CC[N] ;
    real DBH[J] ;
    real dij[J] ;
    int individual[J] ;
  }
  parameters {
    real<lower=-1, upper=1> alpha ;
    real<lower=-3, upper=3> beta ;
    real<lower=0> sigma ;
  }
  transformed parameters {
    real NCI[N] ;
    for(n in 1:N)
      NCI[n] = 0 ;
    for(j in 1:J)
      NCI[individual[j]] = NCI[individual[j]] + DBH[j]^beta*exp(-alpha*dij[j]) ;
  }
  model {
    for(n in 1:N)
      CC[n] ~ normal(NCI[n], sigma) ;
  }
  generated quantities {
    real CCpred[N] ;
    for(n in 1:N)
      CCpred[n] = NCI[n] ;
  }
```

```{r fitMcomp}
# fit <- sampling(Mcomp, chains = 2,
#                 data = list(N = nrow(arrange(data, idTree)),
#                             J = nrow(arrange(Competition, idTreei)),
#                             CC = arrange(data, idTree)$CC,
#                             DBH = arrange(Competition, idTreei)$DBH,
#                             dij = arrange(Competition, idTreei)$dij,
#                             individual = as.numeric(as.factor(arrange(Competition, idTreei)$idTreei))))
# save(fit, file = "./functional_save/ModelCCCompetition.Rdata")
load("./functional_save/ModelCCCompetition.Rdata")
pars <- c("alpha", "beta", "sigma")
alpha <- broom::tidyMCMC(fit, pars = "alpha")$estimate
beta <- broom::tidyMCMC(fit, pars = "beta")$estimate
broom::tidyMCMC(fit, pars = c(pars, "lp__"), droppars = NULL, rhat = T) %>% 
  kable(caption = "Summary table of the model competition only")
```

```{r Ccomp, fig.cap="Model parameters posterior for model competition only."}
mcmc_intervals(as.array(fit), pars = pars)
```

```{r Tcomp, fig.cap="Markov chains trace plot after warmup for model competition only"}
mcmc_trace(as.array(fit), pars = c(pars, "lp__"),
           facet_args = list(labeller = label_parsed))
```

```{r 2comp, fig.cap="Markov chains pairs plot after warmup for model competition only"}
mcmc_pairs(as.array(fit), pars = c(pars, "lp__"))
```

```{r Ycomp, fig.cap="Predictions for model competition only"}
cbind(
  Competition %>% 
    group_by(idTreei) %>% 
    summarise(NCI = sum(DBH^beta*exp(-alpha*dij))) %>% 
    left_join(data, by = c("idTreei" = "idTree")),
  pred = apply(as.matrix(fit, pars = "CCpred"), 2, mean),
  t(apply(as.matrix(fit, pars = "CCpred"), 2, quantile, probs = c(0.05, 0.95)))
) %>% 
  ggplot(aes(x = NCI)) +
  geom_point(aes(y = CC)) +
  geom_text(aes(y = CC, label = idTreei)) +
  geom_line(aes(y = pred), col = "red") +
  geom_ribbon(aes(ymin = `5%`, ymax = `95%`), color = 'red', alpha = 0.2) +
  geom_line(aes(y = `5%`), col = "red", alpha = 1, size = 0.5, linetype = "dashed") +
  geom_line(aes(y = `95%`), col = "red", alpha = 1, size = 0.5, linetype = "dashed")
```

# CC - Gaps

```{r dataGaps}
# gaps <- shapefile(file.path(path, "topography", "Gaps", "gaps4.shp"))
# crs(gaps) <- crs(raster(file.path(path, "biotic", "MNC_ParacouAvril2009_1m.tif")))
# gaps <- spTransform(gaps, '+proj=utm +zone=22 +datum=WGS84 +units=m +no_defs +ellps=WGS84 +towgs84=0,0,0')
# cl <- makeCluster(4)
# clusterExport(cl, list("data", "gaps"))
# Gaps <- clusterMap(cl,
#   function(id,  x, y){
#     d <- 50
#     gaps_sel <- raster::crop(rgeos::gBuffer(gaps, byid=TRUE, width=0), 
#                              raster::extent(matrix(c(x-d, y-d, x+d, y+d), nrow=2)))
#     tree <- data.frame(x = x, y = y)
#     sp::coordinates(tree) <- ~x+y
#     raster::crs(tree) <-  '+proj=utm +zone=22 +datum=WGS84 +units=m +no_defs +ellps=WGS84 +towgs84=0,0,0'
#     if(!is.null(gaps_sel))
#       data.frame(idTree = id,
#                  idGap = gaps_sel$fid,
#                  Area = raster::area(gaps_sel),
#                  Distance = rgeos::gDistance(tree, gaps_sel, byid = T)[,1])
#     },
#   id = data$idTree,
#   x = data$Xutm,
#   y = data$Yutm,
#   SIMPLIFY = F)
# stopCluster(cl)
# rm(cl)
# Gaps <- bind_rows(Gaps)
# Gaps <- Gaps %>% 
#   filter(Area < 500)
# Gaps <- Gaps %>%
#   full_join(dplyr::select(data, idTree)) %>%
#   mutate(Area = ifelse(is.na(Area), 0, Area)) %>%
#   mutate(Distance = ifelse(is.na(Distance), 100, Distance))
# save(Gaps, file = "./functional_save/GapsMatrix.Rdata")
load("./functional_save/GapsMatrix.Rdata")
```


## Relation

```{r CCGaps}
Gaps %>% 
  filter(Area < 500) %>%
  mutate(Area = Area/max(Area)) %>% 
  mutate(Distance = Distance/max(Distance)) %>% 
  group_by(idTree) %>% 
  summarise(Idist = sum(Area*exp(-Distance))) %>% 
  left_join(data) %>% 
  ggplot(aes(Idist, CC, size = DBH, aes = DBH,
             col = Bark, group = NA)) +
  geom_point() +
  geom_smooth()
```

## Disturbance model

$$CC_i \sim \mathcal{N} (\alpha + \beta*\sum _{j<20m} S_j^\beta * e^{-\alpha*d_{i,j}} , \sigma) $$

```{stan Mgaps, output.var="Mgaps", echo=T, eval=F}
  data {
    int N ; // # obs
    int J ; // # gaps
    real CC[N] ;
    real Area[J] ;
    real Distance[J] ;
    int individual[J] ;
  }
  parameters {
    real alpha ;
    real beta ;
    real<lower=0, upper=1> alpha_Idist ;
    real<lower=0, upper=3> beta_Idist ;
    real<lower=0> sigma ;
  }
  transformed parameters {
    real Idist[N] ;
    for(n in 1:N)
      Idist[n] = 0 ;
    for(j in 1:J)
      Idist[individual[j]] = Idist[individual[j]] + Area[j]^beta_Idist*exp(-alpha_Idist*Distance[j]) ;
  }
  model {
    for(n in 1:N)
      CC[n] ~ normal(alpha + beta*Idist[n], sigma) ;
  }
  generated quantities {
    real CCpred[N] ;
    for(n in 1:N)
      CCpred[n] = alpha + beta*Idist[n] ;
  }
```

```{r fitMgaps}
# fit <- sampling(Mgaps, chains = 2,
#                 data = list(N = nrow(arrange(data, idTree)),
#                             J = nrow(arrange(Gaps, idTree)),
#                             CC = arrange(data, idTree)$CC,
#                             Area = arrange(Gaps, idTree)$Area,
#                             Distance = arrange(Gaps, idTree)$Distance,
#                             individual = as.numeric(as.factor(arrange(Gaps, idTree)$idTree))))
# save(fit, file = "./functional_save/ModelCCGaps.Rdata")
load("./functional_save/ModelCCGaps.Rdata")
pars <- c("alpha", "beta", "alpha_Idist", "beta_Idist", "sigma")
alpha <- broom::tidyMCMC(fit, pars = "alpha_Idist")$estimate
beta <- broom::tidyMCMC(fit, pars = "beta_Idist")$estimate
broom::tidyMCMC(fit, pars = c(pars, "lp__"), droppars = NULL, rhat = T) %>% 
  kable(caption = "Summary table of the model gaps only")
```

```{r Cgaps, fig.cap="Model parameters posterior for model gaps only."}
mcmc_intervals(as.array(fit), pars = pars)
```

```{r Tgaps, fig.cap="Markov chains trace plot after warmup for model gaps only"}
mcmc_trace(as.array(fit), pars = c(pars, "lp__"),
           facet_args = list(labeller = label_parsed))
```

```{r 2gaps, fig.cap="Markov chains pairs plot after warmup for model gaps only"}
mcmc_pairs(as.array(fit), pars = c(pars, "lp__"))
```

```{r Ygaps, fig.cap="Predictions for model gaps only"}
cbind(
  Gaps %>% 
    group_by(idTree) %>% 
    summarise(Idisturb = sum(Area^beta*exp(-alpha*Distance))) %>% 
    left_join(data),
  pred = apply(as.matrix(fit, pars = "CCpred"), 2, mean),
  t(apply(as.matrix(fit, pars = "CCpred"), 2, quantile, probs = c(0.05, 0.95)))
) %>% 
  ggplot(aes(x = Idisturb)) +
  geom_point(aes(y = CC, size = DBH)) +
  geom_text(aes(y = CC, label = idTree)) +
  geom_line(aes(y = pred), col = "red") +
  geom_ribbon(aes(ymin = `5%`, ymax = `95%`), color = 'red', alpha = 0.2) +
  geom_line(aes(y = `5%`), col = "red", alpha = 1, size = 0.5, linetype = "dashed") +
  geom_line(aes(y = `95%`), col = "red", alpha = 1, size = 0.5, linetype = "dashed")
```

# Discussion

# References

