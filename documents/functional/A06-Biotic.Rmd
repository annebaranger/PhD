---
title: "A06 : Biotic Model (NCI)"
date: '`r Sys.Date()`'
author: Sylvain Schmitt & Anne Baranger
output:
  bookdown::html_document2:
    number_sections: no
    toc: true
    toc_float: yes
    theme: flatly
  bookdown::pdf_document2:
    includes:
      before_body: ./template/doc_prefix.tex
      in_header: ./template/preamble.tex
    number_sections: false
    toc: false
    keep_tex: true
  bookdown::word_document2: default
linestretch: 1.5
csl: /home/sylvain/Documents/Bibliography/csl/mee.csl
bibliography: /home/sylvain/Documents/Bibliography/library.bib
link-citations: yes
---

```{r setup, include=FALSE}
#rm(list = ls()) ; invisible(gc()) ; set.seed(42)
library(knitr)
library(tidyverse)
library(kableExtra)
library(rstan)
library(bayesplot)
theme_set(bayesplot::theme_default())
opts_chunk$set(
  echo = F, message = F, warning = F, fig.height = 6, fig.width = 6,
  cache = T, cache.lazy = F)
options(mc.cores = parallel::detectCores())
rstan_options(auto_write = T)
path <- "../../data/Paracou/"
```

```{r data, eval=T}
traitsSymphonia <- googlesheets::gs_title("Measures_Symphonia") %>% 
  googlesheets::gs_read("AllTraits") %>% 
  mutate(SLA = as.numeric(SLA), LDMC = as.numeric(LDMC)) %>% 
  mutate(Genus = "Symphonia") %>% 
  rename(Species = Morphotype) %>% 
  mutate(Species = ifelse(Species == "Indet.", 
                          c("globulifera", "sp.1", "sp.1")[fct_recode(Bark, "globulifera" = "G", 
                                     "sp.1" =  "S")], Species))
traitsEschweilera <- googlesheets::gs_title("Measures_Eschweilera") %>% 
  googlesheets::gs_read("AllTraits") %>% 
  filter(!(Plot == 14 & SubPlot == 1 & TreeFieldNum == 760)) %>%  # outlier
  filter(!(Species %in% c("congestiflora","simiorum","persistens")))
traits <- bind_rows(traitsEschweilera, traitsSymphonia) %>% 
  mutate(SpeciesLong = paste(substr(Genus, 1, 1), Species)) 
paracou <- src_sqlite(file.path(path, "trees", "Paracou.sqlite")) %>%
  tbl("Paracou") %>%
  filter(idTree %in% traits$idTree) %>%
  filter(Genus %in% c("Lecythis", "Eschweilera") & Plot %in% c(1, 6, 11, 13:15) & CensusYear == 2017 |
         Genus %in% c("Lecythis", "Eschweilera") & Plot == 16 & CensusYear == 2015 |
         Genus == "Symphonia" & CensusYear == 2015) %>%
  mutate(DBH = CircCorr/pi) %>% 
  collect()
load("./functional_save/env.Rdata")
Individuals <- left_join(traits, paracou) %>% 
  left_join(env, by = "idTree", suffix = c("", ".y")) %>% 
  group_by(Plot, SubPlot, TreeFieldNum, Genus, Species,
           SpeciesLong, Bark, Dawkins, DBH, TWI, NCI) %>%
  summarise_at(vars("SLA", "LDMC", "LT", "LA", "CC",
                    "brBT", "brBD", "brWD"), mean, na.rm = T)  %>%
  ungroup()
load("./functional_save/CompetitionMatrix.Rdata")
rm(traitsEschweilera, traitsSymphonia, traits, paracou, env)
```

# Introduction {-}

The aim of this document is to fit the biotic model with observed values of functional traits for our individuals. We prepared data excluding oultiers and scaling all continuous variable to ease model fit (see figure \@ref(fig:mdata)). We tested the abiotic model with (1) and without mixed effects (2).

```{r mdata, fig.cap="prepared data"}
traits <- c("SLA", "LDMC", "LT", "LA", "CC")
mdata <- lapply(traits, function(trait){
  data_trait <- Individuals[!is.na(unlist(Individuals[,trait])),]
  list(N = nrow(data_trait),
       J = nrow(Competition),
       C = length(unique(data_trait$Genus)),
       S = length(unique(data_trait$Species)),
       Trait = as.numeric(scale(data_trait[trait], center = F)),
       individual = as.numeric(as.factor(Competition$idTree)),
       DBHj = as.numeric(scale(Competition$DBHj, center = F)),
       Deltaj = as.numeric(scale(Competition$dij, center = F)),
       species = as.numeric(as.factor(data_trait$Species)),
       complex = as.numeric(as.factor(data_trait$Genus)),
       speciesincomplex = unique(cbind(as.numeric(as.factor(data_trait$Species)), as.numeric(as.factor(data_trait$Genus))))[order(unique(cbind(as.numeric(as.factor(data_trait$Species)), as.numeric(as.factor(data_trait$Genus))))[,1]),2])})
names(mdata) <- traits
lapply(as.list(traits), function(trait)
  cbind(Model = trait, 
        Trait = mdata[[trait]]$Trait, 
        Individuals[unlist(!is.na(Individuals[trait])),])) %>% 
  bind_rows() %>% 
  ggplot(aes(x = NCI, y = Trait, col = Genus)) +
  geom_point() +
  geom_smooth() +
  facet_wrap(~ Model, scales = "free", nrow = 3)
```

# Model without mixed effects

We explained leaf trait $Trait$ according to competition following a normal law with a linear model form around a Neighborhood Crowding Index (including both neighbor diameter and distance) :

\begin{equation} 
Trait_i \sim \mathcal{N}(\alpha + \beta_{comp}. \sum_{j~|~\delta_{i,j}<\delta_{max}}^{J_i} DBH_j^{\beta_{NCI}}.e^{-\alpha_{NCI}.\delta_{i,j}}, \sigma) \\
(\alpha, \beta_{comp}, \beta_{NCI}) \sim \mathcal{N}^{3}(0, + \infty) \\
(\alpha_{NCI}, \sigma) \sim \Gamma(- \infty, - \infty) 
(\#eq:Competition)
\end{equation}

where:

* $Trait_i$ is a functional trait of an individual i associated to a $DBH_i$ value ;
* $i \in [1,I]$ where I is the number of individuals, i.e. 838 in our dataset;
* $j \in [1,J_i]$ where $J_i$ is the number of neighbors within the radius $\delta_{max}$ surrounding the individual i, and DBH_j the value of DBH for neighbor j;
* $\delta_{i,j}$ is the distance between the individual i and one of its neighbors j;
* $\alpha_{NCI}$ represents the effect of neighbors distance to the individual, lower $\alpha_{NCI}$ enable to strengthen competition effects from trees farther to the individual $i$. $\alpha_{NCI}$ will be computed with positive values;
* $\beta_{NCI}$ represents the idea that bigger neighbor will increase competition on the focal individual, thus $\beta_{NCI}$ was chosen equal to 2 to represent neighbor surface.
* $\alpha$ and $\beta_{comp}$ are linear model parameters and could range in positive or negative value. Normal flat laws were chosen as non informative flat priors on on $\mathbb{R}$;
* $\sigma$ is normal law standard error, and will, therefore, be chosen with positive values;
* Gamma law was chosen as non informative flat prior on $\mathbb{R}^+$ for neighbors distance effect and Normal law standard error.

## Code

```{stan, output.var="Model", echo=T, eval=F}
data {
  int<lower=1>  N ; // # of observations
  int<lower=1>  J ; // # of neighbors
  vector[N] Trait ; // Trait
  vector[N] DBHj ; // DBH neighbor
  vector[N] Deltaj ; // Distance neighbor
  int<lower=1, upper=N>  individual ; // individuals index in neighbor matrix
}
parameters {
}
model {
  Trait ~ normal(, sigma) ; // Likelihood
} 
generated quantities {
  vector[N] Traitpred ;
  Traitpred =  ;
}
```


## Summary

```{r , eval=F}
# fits <- lapply(mdata, function(x) sampling(Model, chains = 2, data = x))
# names(fits) <- traits
# save(fits, file = "./functional_save/NCI.Rdata")
load("./functional_save/NCI.Rdata")
pars <- c()
lapply(as.list(traits), function(trait)
  broom::tidyMCMC(fits[[trait]], pars = c(pars, "lp__"), droppars = NULL, rhat = T) %>%
   mutate(Trait = trait)) %>%
  bind_rows() %>%
  kable() %>%
  kable_styling()
```

## Posteriors

```{r , eval=F, fig.cap="Model parameters posterior."}
cowplot::plot_grid(plotlist = lapply(traits, function(trait)
  mcmc_intervals(as.array(fits[[trait]]), pars = pars)),
  labels = names(data), nrow = 2)
```

## Chains

```{r , eval=F, fig.cap="Markov chains trace plot after warmup for intermediate data."}
mcmc_trace(as.array(fits$LA), pars = c(pars, "lp__"),
             facet_args = list(labeller = label_parsed))
```

## Pairs

```{r , eval=F, fig.cap="Markov chains pairs plot after warmup  for intermediate data."}
mcmc_pairs(as.array(fits$CC), pars = pars)
```

## Predictions

```{r , eval=F, fig.cap="Predictions."}
lapply(as.list(traits), function(trait)
  cbind(fit = trait, 
        Y = mdata[[trait]]$Trait,
        Individuals[unlist(!is.na(Individuals[trait])),],
        Traitpred = apply(as.matrix(fits[[trait]], pars = "Traitpred"), 2, mean),
        sigmaTWI = apply(as.matrix(fits[[trait]], pars = "sigma"), 2, mean),
        mu5 = unlist(apply(as.matrix(fits[[trait]], pars = "Traitpred"), 2, quantile, probs = 0.05)),
        mu95 = unlist(apply(as.matrix(fits[[trait]], pars = "Traitpred"), 2, quantile, probs = 0.95)),
        sigmaTWI95 = unlist(apply(as.matrix(fits[[trait]], pars = "sigma"), 2, quantile, probs = 0.95))
        )) %>% 
  bind_rows() %>% 
  mutate(Y5sigmafix = qnorm(0.05, mean = mu5, sd = sigmaTWI)) %>% 
  mutate(Y95sigmafix = qnorm(0.95, mean = mu95, sd = sigmaTWI)) %>% 
  mutate(Y5 = qnorm(0.05, mean = mu5, sd = sigmaTWI95)) %>% 
  mutate(Y95 = qnorm(0.95, mean = mu95, sd = sigmaTWI95)) %>% 
  ggplot(aes(x = TWI)) +
  geom_point(aes(y = Y)) +
  geom_line(aes(y = Traitpred)) +
  geom_ribbon(aes(ymin = Y5, ymax = Y95, color = 'Ypred'), alpha = 0.2) +
  geom_ribbon(aes(ymin = Y5sigmafix, ymax = Y95sigmafix, color = 'Ysigmafix'), alpha = 0.2) +
  geom_ribbon(aes(ymin = mu5, ymax = mu95, color = 'mu'), alpha = 0.2) +
  facet_wrap(~ fit, scales = "free", nrow = 3)
```

## Diagnostic


# Model with mixed effects

*We added a fixed complex effect and random species effect on parameters...*

## Code

```{stan, output.var="Model", echo=T, eval=F}
data {
  int<lower=1>  N ; // # of observations
  int<lower=1>  J ; // # of neighbors
  vector[N] Trait ; // Trait
  vector[N] DBHj ; // DBH neighbor
  vector[N] Deltaj ; // Distance neighbor
  int<lower=1, upper=N>  individual ; // individuals index in neighbor matrix
  int<lower=1, upper=S> species[N] ; // species index
  int<lower=1, upper=C> speciesincomplex[S] ; // species index wihtin complex
  int<lower=1, upper=C> complex[N] ; // species index
}
parameters {
}
model {
  Trait ~ normal(, sigma) ; // Likelihood
} 
generated quantities {
  vector[N] Traitpred ;
  Traitpred =  ;
}
```

## Summary

```{r , eval=F}
# fits <- lapply(mdata, function(x) sampling(Model, chains = 2, data = x))
# names(fits) <- traits
# save(fits, file = "./functional_save/TWIRNE.Rdata")
load("./functional_save/TWIRNE.Rdata")
pars <- c( "alpha_c", "betaTWI_c", "sigmaIntercept", "sigmaTWI", "sigma" )
lapply(as.list(traits), function(trait)
  broom::tidyMCMC(fits[[trait]], pars = c(pars, "lp__"), droppars = NULL, rhat = T) %>%
   mutate(Trait = trait)) %>%
  bind_rows() %>%
  kable() %>%
  kable_styling()
```

## Posteriors

```{r , eval=F, fig.cap="Model parameters posterior."}
cowplot::plot_grid(plotlist = lapply(traits, function(trait)
  mcmc_intervals(as.array(fits[[trait]]), regex_pars = pars)),
  labels = names(data), nrow = 2)
```

```{r , eval=F, fig.cap="Model parameters posterior."}
cowplot::plot_grid(plotlist = lapply(traits, function(trait)
  mcmc_intervals(as.array(fits[[trait]]), regex_pars = "betaTWI")),
  labels = names(data), nrow = 2)
```

## Chains

```{r , eval=F, fig.cap="Markov chains trace plot after warmup for intermediate data."}
mcmc_trace(as.array(fits$SLA), regex_pars = c(pars, "lp__"),
             facet_args = list(labeller = label_parsed))
```

## Pairs

```{r , eval=F, fig.cap="Markov chains pairs plot after warmup  for intermediate data."}
mcmc_pairs(as.array(fits$SLA), regex_pars = pars)
```

## Predictions

```{r , eval=F, fig.cap="Predictions.", fig.width=12, fig.height=12}
lapply(as.list(names(mdata)), function(type)
  cbind(type = type, 
        Y = mdata[[type]]$Trait,
        TWI = as.numeric(scale(Individuals[!is.na(unlist(Individuals[,type])),"TWI"])),
        Individuals[!is.na(unlist(Individuals[,type])),],
        muEschweilera = apply(as.matrix(fits[[type]], 
                                        pars = paste0("Trait_pred[",
                                                      1:mdata[[type]]$N,",1]")), 
                              2, mean),
        muSymphonia = apply(as.matrix(fits[[type]], 
                                      pars = paste0("Trait_pred[",
                                                    1:mdata[[type]]$N,",2]")), 
                            2, mean),
        muEschweilera5 = apply(as.matrix(fits[[type]], 
                                         pars = paste0("Trait_pred[",
                                                       1:mdata[[type]]$N,",1]")), 
                               2, quantile, probs = 0.05),
        muSymphonia5 = apply(as.matrix(fits[[type]], 
                                       pars = paste0("Trait_pred[",
                                                      1:mdata[[type]]$N,",2]")), 
                             2, quantile, probs = 0.05),
        muEschweilera95 = apply(as.matrix(fits[[type]], 
                                          pars = paste0("Trait_pred[",
                                                      1:mdata[[type]]$N,",1]")), 
                                2, quantile, probs = 0.95),
        muSymphonia95 = apply(as.matrix(fits[[type]], 
                                        pars = paste0("Trait_pred[",
                                                      1:mdata[[type]]$N,",2]")), 
                              2, quantile, probs = 0.95)
  )) %>% 
  bind_rows() %>% 
  ggplot(aes(x = TWI)) +
  geom_point(aes(y = Y, col = as.factor(Genus))) +
  geom_ribbon(aes(ymin = muEschweilera5, ymax = muEschweilera95,
                  col = "Eschweilera"), alpha = 0.2) +
  geom_ribbon(aes(ymin = muSymphonia5, ymax = muSymphonia95,
                  col = "Symphonia"), alpha = 0.2) +
  geom_line(aes(y = muEschweilera, col = "Eschweilera")) +
  geom_line(aes(y = muSymphonia, col = "Symphonia")) +
  facet_wrap(~ type, scales = "free", nrow = 3)
```

## Diagnostic

# Conclusion

# References
