---
title: "A05 : DBH"
date: '`r Sys.Date()`'
author: Sylvain Schmitt & Anne Baranger
output:
  bookdown::html_document2:
    number_sections: no
    toc: true
    toc_float: yes
    theme: flatly
  bookdown::pdf_document2:
    includes:
      before_body: ./template/doc_prefix.tex
      in_header: ./template/preamble.tex
    number_sections: false
    toc: false
    keep_tex: true
  bookdown::word_document2: default
linestretch: 1.5
# csl: /home/sylvain/Documents/Bibliography/csl/mee.csl
# bibliography: /home/sylvain/Documents/Bibliography/library.bib
link-citations: yes
---

```{r setup, include=FALSE}
rm(list = ls()) ; invisible(gc()) ; set.seed(42)
library(knitr)
library(tidyverse)
library(kableExtra)
library(rstan)
library(bayesplot)
theme_set(bayesplot::theme_default())
opts_chunk$set(
  echo = F, message = F, warning = F, fig.height = 6, fig.width = 6,
  cache = T, cache.lazy = F)
options(mc.cores = parallel::detectCores())
rstan_options(auto_write = T)
path <- "../../data/Paracou/"
```

# Introduction {-}

The aim of this document is to fit the ontogenic model with observed values of functional traits for our individuals. We prepared data excluding oultiers and scaling all continuous variable to ease model fit (see figure \@ref(fig:mdata)). We tested the ontogenic model without mixed effects (1), with random effects on species (2) and with mixed effects (3).

```{r data, eval=T}
traitsSymphonia <- googlesheets::gs_title("Measures_Symphonia") %>% 
  googlesheets::gs_read("AllTraits") %>% 
  mutate(SLA = as.numeric(SLA), LDMC = as.numeric(LDMC)) %>% 
  mutate(Genus = "Symphonia") %>% 
  rename(Species = Morphotype)
traitsEschweilera <- googlesheets::gs_title("Measures_Eschweilera") %>% 
  googlesheets::gs_read("AllTraits")
traits <- bind_rows(traitsEschweilera, traitsSymphonia) %>% 
  mutate(SpeciesLong = paste(substr(Genus, 1, 1), Species)) ; rm(traitsEschweilera, traitsSymphonia)
paracou <- src_sqlite(file.path(path, "trees", "Paracou.sqlite")) %>%
  tbl("Paracou") %>%
  filter(idTree %in% traits$idTree) %>%
  filter(Genus %in% c("Lecythis", "Eschweilera") & Plot %in% c(1, 6, 11, 13:15) & CensusYear == 2017 |
         Genus %in% c("Lecythis", "Eschweilera") & Plot == 16 & CensusYear == 2015 |
         Genus == "Symphonia" & CensusYear == 2015) %>%
  mutate(DBH = CircCorr/pi) %>% 
  collect()
load("./functional_save/env.Rdata")
Individuals <- left_join(traits, paracou) %>% 
  filter(!(Plot == 14 & SubPlot == 1 & TreeFieldNum == 760)) %>%  # rejection individual
  filter(!(SpeciesLong %in% c("E congestiflora","E simiorum","L persistens"))) %>% 
  left_join(env, by = "idTree", suffix = c("", ".y")) %>% 
  group_by(Plot, SubPlot, TreeFieldNum, Genus, Species,
           SpeciesLong, Bark, Dawkins, DBH, TWI, Curvature) %>%
  summarise_at(vars("SLA", "LDMC", "LT", "LA", "CC",
                    "brBT", "brBD", "brWD"), mean, na.rm = T)  %>%
  mutate(invSLA=1/SLA) %>% 
  mutate(invLA=1/LA) %>% 
  ungroup()
rm(traits, paracou, env)
```


```{r DataForStanRNE}
traits <- c("invSLA", "LDMC", "LT", "invLA", "CC")
mdata <- lapply(traits, function(trait){
  data_trait <- Individuals[!is.na(unlist(Individuals[,trait])),]
  list(N = nrow(data_trait),
       C = length(unique(data_trait$Genus)),
       S = length(unique(data_trait$Species)),
       Trait = as.numeric(scale(data_trait[trait],center = F)),
       DBH = as.numeric(scale(data_trait$DBH,center = F)),
       species = as.numeric(as.factor(data_trait$Species)),
       complex = as.numeric(as.factor(data_trait$Genus)),
       speciesincomplex = unique(cbind(as.numeric(as.factor(data_trait$Species)), as.numeric(as.factor(data_trait$Genus))))[order(unique(cbind(as.numeric(as.factor(data_trait$Species)), as.numeric(as.factor(data_trait$Genus))))[,1]),2])})
names(mdata) <- traits
# mdata1 <- lapply(traits, function(trait){
#   data_trait <- filter(Individuals[!is.na(unlist(Individuals[,trait])),],Genus=="Eschweilera")
#   list(N = nrow(data_trait),
#        C = length(unique(data_trait$Genus)),
#        S = length(unique(data_trait$Species)),
#        Trait = as.numeric(scale(data_trait[trait],center = F)),
#        DBH = as.numeric(scale(data_trait$DBH,center = F)),
#        species = as.numeric(as.factor(data_trait$Species)),
#        complex = as.numeric(as.factor(data_trait$Genus)),
#        speciesincomplex = unique(cbind(as.numeric(as.factor(data_trait$Species)), as.numeric(as.factor(data_trait$Genus))))[order(unique(cbind(as.numeric(as.factor(data_trait$Species)), as.numeric(as.factor(data_trait$Genus))))[,1]),2])})
# names(mdata1) <- traits
# mdata2 <- lapply(traits, function(trait){
#   data_trait <- filter(Individuals[!is.na(unlist(Individuals[,trait])),],Genus=="Symphonia")
#   list(N = nrow(data_trait),
#        C = length(unique(data_trait$Genus)),
#        S = length(unique(data_trait$Species)),
#        Trait = as.numeric(scale(data_trait[trait],center = F)),
#        DBH = as.numeric(scale(data_trait$DBH,center = F)),
#        species = as.numeric(as.factor(data_trait$Species)),
#        complex = as.numeric(as.factor(data_trait$Genus)),
#        speciesincomplex = unique(cbind(as.numeric(as.factor(data_trait$Species)), as.numeric(as.factor(data_trait$Genus))))[order(unique(cbind(as.numeric(as.factor(data_trait$Species)), as.numeric(as.factor(data_trait$Genus))))[,1]),2])})
# names(mdata2) <- traits
# rm(Individuals)
```


# Simplest model

\begin{equation} 
Trait_i \sim \mathcal{N}(\cfrac{\alpha . DBH_i}{\beta + DBH_i},\sigma) 
(\#eq:Ontogeny)
\end{equation}

##  Code

```{stan Model, output.var="Model", echo=T, eval=F}
data {
  int<lower=1> N ; //  obs
  vector[N] Trait ; // Phenotype continuous descriptor
  vector[N] DBH ; // Diameter at breast height
}
parameters {
  real<lower=0> alpha ; // intercept
  real<lower=0> beta ; // trait parameter
  real<lower=0> sigma ; // variance
}
model {
  Trait ~ normal((alpha*DBH)./(DBH + beta), sigma) ; // Likelihood
}
generated quantities {
  vector[N] Trait_pred ;
  Trait_pred = (alpha*DBH) ./ (beta+DBH) ; // Predictions
} // empty line at the end (C++)

```

## Summary

```{r }
# fits <- lapply(mdata, function(x) sampling(Model, chains = 2, data = x))
# names(fits) <- traits
# save(fits, file = "./functional_save/OntoM1.Rdata")
load("./functional_save/OntoM1.Rdata")
pars <- c( "alpha", "beta", "sigma" )
lapply(as.list(traits), function(trait)
  broom::tidyMCMC(fits[[trait]], pars = c(pars, "lp__"), droppars = NULL, rhat = T) %>%
   mutate(Trait = trait)) %>%
  bind_rows() %>%
  kable() %>%
  kable_styling()
```

## Posteriors

```{r , fig.cap="Model parameters posterior."}
cowplot::plot_grid(plotlist = lapply(traits, function(trait)
  mcmc_intervals(as.array(fits[[trait]]), pars = pars)),
  labels = names(data), nrow = 2)
```

## Chains

```{r , fig.cap="Markov chains trace plot after warmup for intermediate data."}
mcmc_trace(as.array(fits$invSLA), pars = c(pars, "lp__"),
             facet_args = list(labeller = label_parsed))
```

## Pairs

```{r , fig.cap="Markov chains pairs plot after warmup  for intermediate data."}
mcmc_pairs(as.array(fits$invSLA), pars = pars)
```

## Predictions
```{r , fig.cap="Predictions.",eval=F}
lapply(as.list(traits), function(trait)
  cbind(fit = trait, 
        Y = mdata[[trait]]$Trait,
        Individuals[unlist(!is.na(Individuals[trait])),],
        Traitpred = apply(as.matrix(fits[[trait]], pars = "Trait_pred"), 2, mean),
        sigmaTWI = apply(as.matrix(fits[[trait]], pars = "sigma"), 2, mean),
        mu5 = unlist(apply(as.matrix(fits[[trait]], pars = "Trait_pred"), 2, quantile, probs = 0.05)),
        mu95 = unlist(apply(as.matrix(fits[[trait]], pars = "Trait_pred"), 2, quantile, probs = 0.95)),
        sigmaTWI95 = unlist(apply(as.matrix(fits[[trait]], pars = "sigma"), 2, quantile, probs = 0.95))
        )) %>% 
  bind_rows() %>% 
  mutate(Y5sigmafix = qnorm(0.05, mean = mu5, sd = sigmaTWI)) %>% 
  mutate(Y95sigmafix = qnorm(0.95, mean = mu95, sd = sigmaTWI)) %>% 
  mutate(Y5 = qnorm(0.05, mean = mu5, sd = sigmaTWI95)) %>% 
  mutate(Y95 = qnorm(0.95, mean = mu95, sd = sigmaTWI95)) %>% 
  ggplot(aes(x = TWI)) +
  geom_point(aes(y = Y)) +
  geom_line(aes(y = Traitpred)) +
  geom_ribbon(aes(ymin = Y5, ymax = Y95, color = 'Ypred'), alpha = 0.2) +
  geom_ribbon(aes(ymin = Y5sigmafix, ymax = Y95sigmafix, color = 'Ysigmafix'), alpha = 0.2) +
  geom_ribbon(aes(ymin = mu5, ymax = mu95, color = 'mu'), alpha = 0.2) +
  facet_wrap(~ fit, scales = "free", nrow = 3)
```

**Alpha strongly linked to beta**


## Obs
Converge with symphonia and Eschweleira Dataset, when variables are reduced but not centered! 



# Model with random effect only on species

\begin{equation} 
Trait_i \sim \mathcal{N}(\cfrac{\alpha_{s} . DBH_i}{\beta_{s} + DBH_i},\sigma) 
\\ (\alpha_{s} \sim \mathcal{N}(\alpha, \sigma_{intercept})
\\ (\beta{s} \sim \mathcal{N}(\beta_{DBH}, \sigma_{DBH})
(\#eq:Ontogeny)
\end{equation}

## Code

```{stan output.var="Model", echo=T, eval=F}
data {
  int<lower=1> N ; // # obs
  int<lower=1> S ; // # species
  vector[N] Trait ; // Phenotype continuous descriptor
  vector[N] DBH ; // Topographic Wetness Index
  int<lower=1, upper=S> species[N] ; // species index
}
parameters {
  vector<lower=0>[S] alpha_s ; // Abiotic intercept for species
  real <lower=0> alpha ;
  vector<lower=0> [S] betaDBH_s ; // Abiotic slope for species
  real<lower=0> betaDBH ; // Abiotic slope for complexes
  real<lower=0> sigmaIntercept ; // Abiotic intercept variance for species
  real<lower=0> sigmaDBH ; // Abiotic slope variance for species
  real<lower=0> sigma ; // Abiotic variance
}
model {
  alpha_s ~ normal(alpha, sigmaIntercept) ;
  betaDBH_s ~ normal(betaDBH, sigmaDBH) ;
  Trait ~ normal((alpha_s[species].*DBH) ./ (betaDBH_s[species]+DBH), sigma) ; // Likelihood
}
generated quantities {
   matrix[N,S] Trait_pred ;
   for(s in 1:S)
    Trait_pred[,s] = (alpha_s[s]*DBH) ./ (betaDBH_s[s]+DBH) ; // Predictions
}
```

## Summary

```{r}
# fits <- lapply(mdata, function(x) sampling(Model, chains = 2, data = x))
# names(fits) <- traits
# save(fits, file = "./functional_save/OntoM2.Rdata")
load("./functional_save/OntoM2.Rdata")

pars <- c( "alpha", "betaDBH", "sigmaIntercept", "sigmaDBH", "sigma" )
lapply(as.list(traits), function(trait)
  broom::tidyMCMC(fits[[trait]], pars = c(pars, "lp__"), droppars = NULL, rhat = T) %>%
   mutate(Trait = trait)) %>%
  bind_rows() %>%
  kable() %>%
  kable_styling()
```

## Posteriors

```{r , fig.cap="Model parameters posterior.", fig.width=12}
cowplot::plot_grid(plotlist = lapply(traits, function(trait)
  mcmc_intervals(as.array(fits[[trait]]), regex_pars = pars)),
  labels = names(data), nrow = 2)
```
## Chains

```{r , fig.cap="Markov chains trace plot after warmup for intermediate data.", fig.width=12}
mcmc_trace(as.array(fits$invSLA), regex_pars = c(pars, "lp__"),
             facet_args = list(labeller = label_parsed))
```

## Pairs

```{r , fig.cap="Markov chains pairs plot after warmup  for intermediate data."}
mcmc_pairs(as.array(fits$invSLA), regex_pars = pars)
```

## Obs
Do not converge because of sigma.


# Model with random nested effect on species and complex

## Code

```{stan output.var="Model",echo=T, eval=F}
data {
  int<lower=1> N ; // # obs
  int<lower=1> S ; // # species
  int<lower=1> C ; // # complex
  vector[N] Trait ; // Phenotype continuous descriptor
  vector[N] DBH ; // Topographic Wetness Index
  int<lower=1, upper=S> species[N] ; // species index
  int<lower=1, upper=C> speciesincomplex[S] ; // species index wihtin complex
  int<lower=1, upper=C> complex[N] ; // species index
}
parameters {
  vector<lower=0>[S] alpha_s ; // Abiotic intercept for species
  vector<lower=0> [C] alpha_c ; // Abiotic intercept for complexes
  vector<lower=0> [S] betaDBH_s ; // Abiotic slope for species
  vector<lower=0> [C] betaDBH_c ; // Abiotic slope for complexes
  real<lower=0> sigmaIntercept ; // Abiotic intercept variance for species
  real<lower=0> sigmaDBH ; // Abiotic slope variance for species
  real<lower=0> sigma ; // Abiotic variance
}
// transformed parameters {
  // vector<lower=0> [S] betaDBH_s ; // Abiotic slope for species
//  vector<lower=0> [C] betaDBH_c ; // Abiotic slope for complexes
 // betaDBH_s = exp(-0.5*betaDBHP_s) ;
//  betaDBH_c = exp(-0.5*betaDBHP_c) ;
//}
model {
  betaDBH_c ~ lognormal(0,1) ;
  alpha_s ~ normal(alpha_c[speciesincomplex], sigmaIntercept) ;
  betaDBH_s ~ normal(betaDBH_c[speciesincomplex], sigmaDBH) ;
  Trait ~ normal((alpha_s[species].*DBH) ./ (betaDBH_s[species]+DBH), sigma) ; // Likelihood
}
generated quantities {
   matrix[N,C] Trait_pred ;
   for(c in 1:C)
    Trait_pred[,c] = (alpha_c[c]*DBH) ./ (betaDBH_c[c]+DBH) ; // Predictions
}
```

## Summary

```{r }
fits <- lapply(mdata, function(x) sampling(Model, chains = 2, data = x))
names(fits) <- traits
# save(fits, file = "./functional_save/OntoM3.Rdata")
# load("./functional_save/OntoM3.Rdata")

pars <- c( "alpha_c", "betaDBH_c", "sigmaIntercept", "sigmaDBH", "sigma" )
lapply(as.list(traits), function(trait)
  broom::tidyMCMC(fits[[trait]], pars = c(pars, "lp__"), droppars = NULL, rhat = T) %>%
   mutate(Trait = trait)) %>%
  bind_rows() %>%
  kable() %>%
  kable_styling()
```
## Posteriors

```{r , fig.cap="Model parameters posterior."}
cowplot::plot_grid(plotlist = lapply(traits, function(trait)
  mcmc_intervals(as.array(fits[[trait]]), regex_pars = pars)),
  labels = traits, nrow = 2)
```
```{r , fig.cap="Model parameters posterior."}
cowplot::plot_grid(plotlist = lapply(traits, function(trait)
  mcmc_intervals(as.array(fits[[trait]]), regex_pars = "betaDBH_c")),
  labels = traits, nrow = 2)
```

```{r , fig.cap="Model parameters posterior."}
cowplot::plot_grid(plotlist = lapply(traits, function(trait)
  mcmc_areas(as.array(fits[[trait]]), regex_pars = "betaDBH_c")),
  labels = traits, nrow = 2)
```

## Chains

```{r , fig.cap="Markov chains trace plot after warmup for intermediate data."}
mcmc_trace(as.array(fits$invLA), regex_pars = c(pars, "lp__"),
             facet_args = list(labeller = label_parsed))
```

## Pairs

```{r , fig.cap="Markov chains pairs plot after warmup  for intermediate data.",fig.height=12}
mcmc_pairs(as.array(fits$invSLA), regex_pars = pars)
```

## Predictions

```{r , fig.cap="Predictions.", fig.width=12, fig.height=12}
lapply(as.list(names(mdata)), function(type)
  cbind(type = type, 
        trait = as.numeric(scale(Individuals[!is.na(unlist(Individuals[,type])),type],center=F)),
        DBH = as.numeric(scale(Individuals[!is.na(unlist(Individuals[,type])),"DBH"],center=F)),
        Individuals[!is.na(unlist(Individuals[,type])),],
        muEschweilera = apply(as.matrix(fits[[type]], 
                                        pars = paste0("Trait_pred[",
                                                      1:mdata[[type]]$N,",1]")), 
                              2, mean),
        muSymphonia = apply(as.matrix(fits[[type]], 
                                      pars = paste0("Trait_pred[",
                                                    1:mdata[[type]]$N,",2]")), 
                            2, mean),
        muEschweilera5 = apply(as.matrix(fits[[type]], 
                                         pars = paste0("Trait_pred[",
                                                       1:mdata[[type]]$N,",1]")), 
                               2, quantile, probs = 0.05),
        muSymphonia5 = apply(as.matrix(fits[[type]], 
                                       pars = paste0("Trait_pred[",
                                                      1:mdata[[type]]$N,",2]")), 
                             2, quantile, probs = 0.05),
        muEschweilera95 = apply(as.matrix(fits[[type]], 
                                          pars = paste0("Trait_pred[",
                                                      1:mdata[[type]]$N,",1]")), 
                                2, quantile, probs = 0.95),
        muSymphonia95 = apply(as.matrix(fits[[type]], 
                                        pars = paste0("Trait_pred[",
                                                      1:mdata[[type]]$N,",2]")), 
                              2, quantile, probs = 0.95)
  )) %>% 
  bind_rows() %>% 
  ggplot(aes(x = DBH)) +
  geom_point(aes(y = trait, col = as.factor(Genus))) +
  geom_line(aes(y = muEschweilera, col = "Eschweilera")) +
  geom_line(aes(y = muSymphonia, col = "Symphonia")) +
  geom_ribbon(aes(ymin = muEschweilera5, ymax = muEschweilera95,
                  col = "Eschweilera"), alpha = 0.2) +
    geom_ribbon(aes(ymin = muSymphonia5, ymax = muSymphonia95,
                  col = "Symphonia"), alpha = 0.2) +
  facet_wrap(~ type, scales = "free", nrow = 3)
```
