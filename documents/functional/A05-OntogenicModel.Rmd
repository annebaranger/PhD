---
title: "A05 : DBH"
date: '`r Sys.Date()`'
author: Sylvain Schmitt & Anne Baranger
output:
  bookdown::html_document2:
    number_sections: no
    toc: true
    toc_float: yes
    theme: flatly
  bookdown::pdf_document2:
    includes:
      before_body: ./template/doc_prefix.tex
      in_header: ./template/preamble.tex
    number_sections: false
    toc: false
    keep_tex: true
  bookdown::word_document2: default
linestretch: 1.5
csl: /home/sylvain/Documents/Bibliography/csl/mee.csl
bibliography: /home/sylvain/Documents/Bibliography/library.bib
link-citations: yes
---

```{r setup, include=FALSE}
rm(list = ls()) ; invisible(gc()) ; set.seed(42)
library(knitr)
library(tidyverse)
library(kableExtra)
library(rstan)
library(bayesplot)
theme_set(bayesplot::theme_default())
opts_chunk$set(
  echo = F, message = F, warning = F, fig.height = 6, fig.width = 6,
  cache = T, cache.lazy = F)
options(mc.cores = parallel::detectCores())
rstan_options(auto_write = T)
path <- "../../data/Paracou/"
```

# Data
```{r data, eval=T}
traitsSymphonia <- googlesheets::gs_title("Measures_Symphonia") %>% 
  googlesheets::gs_read("AllTraits") %>% 
  mutate(SLA = as.numeric(SLA), LDMC = as.numeric(LDMC)) %>% 
  mutate(Genus = "Symphonia") %>% 
  rename(Species = Morphotype)
traitsEschweilera <- googlesheets::gs_title("Measures_Eschweilera") %>% 
  googlesheets::gs_read("AllTraits")
traits <- bind_rows(traitsEschweilera, traitsSymphonia) %>% 
  mutate(SpeciesLong = paste(substr(Genus, 1, 1), Species)) ; rm(traitsEschweilera, traitsSymphonia)
paracou <- src_sqlite(file.path(path, "trees", "Paracou.sqlite")) %>%
  tbl("Paracou") %>%
  filter(idTree %in% traits$idTree) %>%
  filter(Genus %in% c("Lecythis", "Eschweilera") & Plot %in% c(1, 6, 11, 13:15) & CensusYear == 2017 |
         Genus %in% c("Lecythis", "Eschweilera") & Plot == 16 & CensusYear == 2015 |
         Genus == "Symphonia" & CensusYear == 2015) %>%
  mutate(DBH = CircCorr/pi) %>% 
  collect()
load("./functional_save/env.Rdata")
Individuals <- left_join(traits, paracou) %>% 
  filter(!(Plot == 14 & SubPlot == 1 & TreeFieldNum == 760)) %>%  # rejection individual
  filter(!(SpeciesLong %in% c("E congestiflora","E simiorum","L persistens"))) %>% 
  left_join(env, by = "idTree", suffix = c("", ".y")) %>% 
  group_by(Plot, SubPlot, TreeFieldNum, Genus, Species,
           SpeciesLong, Bark, Dawkins, DBH, TWI, Curvature) %>%
  summarise_at(vars("SLA", "LDMC", "LT", "LA", "CC",
                    "brBT", "brBD", "brWD"), mean, na.rm = T)  %>%
  mutate(invSLA=1/SLA) %>% 
  mutate(invLA=1/LA) %>% 
  ungroup()
rm(traits, paracou, env)
```


```{r DataForStanRNE}
traits <- c("invSLA", "LDMC", "LT", "invLA", "CC")
mdata <- lapply(traits, function(trait){
  data_trait <- Individuals[!is.na(unlist(Individuals[,trait])),]
  list(N = nrow(data_trait),
       C = length(unique(data_trait$Genus)),
       S = length(unique(data_trait$Species)),
       Trait = as.numeric(scale(data_trait[trait],center = F)),
       DBH = as.numeric(scale(data_trait$DBH,center = F)),
       species = as.numeric(as.factor(data_trait$Species)),
       complex = as.numeric(as.factor(data_trait$Genus)),
       speciesincomplex = unique(cbind(as.numeric(as.factor(data_trait$Species)), as.numeric(as.factor(data_trait$Genus))))[order(unique(cbind(as.numeric(as.factor(data_trait$Species)), as.numeric(as.factor(data_trait$Genus))))[,1]),2])})
names(mdata) <- traits
mdata1 <- lapply(traits, function(trait){
  data_trait <- filter(Individuals[!is.na(unlist(Individuals[,trait])),],Genus=="Eschweilera")
  list(N = nrow(data_trait),
       C = length(unique(data_trait$Genus)),
       S = length(unique(data_trait$Species)),
       Trait = as.numeric(scale(data_trait[trait],center = F)),
       DBH = as.numeric(scale(data_trait$DBH,center = F)),
       species = as.numeric(as.factor(data_trait$Species)),
       complex = as.numeric(as.factor(data_trait$Genus)),
       speciesincomplex = unique(cbind(as.numeric(as.factor(data_trait$Species)), as.numeric(as.factor(data_trait$Genus))))[order(unique(cbind(as.numeric(as.factor(data_trait$Species)), as.numeric(as.factor(data_trait$Genus))))[,1]),2])})
names(mdata1) <- traits
mdata2 <- lapply(traits, function(trait){
  data_trait <- filter(Individuals[!is.na(unlist(Individuals[,trait])),],Genus=="Symphonia")
  list(N = nrow(data_trait),
       C = length(unique(data_trait$Genus)),
       S = length(unique(data_trait$Species)),
       Trait = as.numeric(scale(data_trait[trait],center = F)),
       DBH = as.numeric(scale(data_trait$DBH,center = F)),
       species = as.numeric(as.factor(data_trait$Species)),
       complex = as.numeric(as.factor(data_trait$Genus)),
       speciesincomplex = unique(cbind(as.numeric(as.factor(data_trait$Species)), as.numeric(as.factor(data_trait$Genus))))[order(unique(cbind(as.numeric(as.factor(data_trait$Species)), as.numeric(as.factor(data_trait$Genus))))[,1]),2])})
names(mdata2) <- traits
rm(Individuals)
```


# Simplest model

##  Code M1

```{stan Model, output.var="Model", echo=T, eval=F}
data {
  int[lower=1] N ; //  obs
  vector[N] Trait ; // Phenotype continuous descriptor
  vector[N] DBH ; // Diameter at breast height
}
parameters {
  real<lower=0> alpha ; // intercept
  real<lower=0> beta ; // trait parameter
  real<lower=0> sigma ; // variance
}
model {
  Trait ~ normal((alpha*DBH)./(DBH + beta), sigma) ; // Likelihood
}
generated quantities {
  vector[N] Trait_pred ;
  Trait_pred = (alpha*DBH) / (beta+DBH) ; // Predictions
} // empty line at the end (C++)

```

## Summary

```{r }
# fits <- lapply(mdata, function(x) sampling(Model, chains = 2, data = x))
# names(fits) <- traits
# save(fits, file = "./functional_save/OntoM1.Rdata")
load("./functional_save/OntoM1.Rdata")
pars <- c( "alpha", "beta", "sigma" )
lapply(as.list(traits), function(trait)
  broom::tidyMCMC(fits[[trait]], pars = c(pars, "lp__"), droppars = NULL, rhat = T) %>%
   mutate(Trait = trait)) %>%
  bind_rows() %>%
  kable() %>%
  kable_styling()
```

## Posteriors

```{r , fig.cap="Model parameters posterior."}
cowplot::plot_grid(plotlist = lapply(traits, function(trait)
  mcmc_intervals(as.array(fits[[trait]]), pars = pars)),
  labels = names(data), nrow = 2)
```

## Chains

```{r , fig.cap="Markov chains trace plot after warmup for intermediate data."}
mcmc_trace(as.array(fits$invSLA), pars = c(pars, "lp__"),
             facet_args = list(labeller = label_parsed))
```

## Pairs

```{r , fig.cap="Markov chains pairs plot after warmup  for intermediate data."}
mcmc_pairs(as.array(fits$CC), pars = pars)
```
**Alpha strongly linked to beta**


## Obs
Converge with symphonia and Eschweleira Dataset, when variables are reduced but not centered! 



# Model with random effect only on species

\begin{equation} 
$$Trait_i \sim \mathcal{N}(\cfrac{\alpha_{s} . DBH_i}{\beta_{s} + DBH_i},\sigma) 
\\ (\alpha_{s} \sim \mathcal{N}(\alpha, \sigma_{intercept})
\\ (\beta{s} \sim \mathcal{N}(\beta_{DBH}, \sigma_{DBH})$$
(\#eq:Ontogeny)
\end{equation}

## Code

```{stan output.var="Model", echo=T, eval=F}
data {
  int<lower=1> N ; // # obs
  int<lower=1> S ; // # species
  vector[N] Trait ; // Phenotype continuous descriptor
  vector[N] DBH ; // Topographic Wetness Index
  int<lower=1, upper=S> species[N] ; // species index
}
parameters {
  vector<lower=0>[S] alpha_s ; // Abiotic intercept for species
  real <lower=0> alpha ;
  vector<lower=0> [S] betaDBH_s ; // Abiotic slope for species
  real<lower=0> betaDBH ; // Abiotic slope for complexes
  real<lower=0> sigmaIntercept ; // Abiotic intercept variance for species
  real<lower=0> sigmaDBH ; // Abiotic slope variance for species
  real<lower=0> sigma ; // Abiotic variance
}
model {
  alpha_s ~ normal(alpha, sigmaIntercept) ;
  betaDBH_s ~ normal(betaDBH, sigmaDBH) ;
  Trait ~ normal((alpha_s[species].*DBH) ./ (betaDBH_s[species]+DBH), sigma) ; // Likelihood
}
generated quantities {
   matrix[N,S] Trait_pred ;
   for(s in 1:S)
    Trait_pred[,s] = (alpha_s[s]*DBH) ./ (betaDBH_s[s]+DBH) ; // Predictions
}
```

## Summary

```{r }
# fits <- lapply(mdata, function(x) sampling(Model, chains = 2, data = x))
# names(fits) <- traits
# save(fits, file = "./functional_save/OntoM2.Rdata")
load("./functional_save/OntoM2.Rdata")

pars <- c( "alpha", "betaDBH", "sigmaIntercept", "sigmaDBH", "sigma" )
lapply(as.list(traits), function(trait)
  broom::tidyMCMC(fits[[trait]], pars = c(pars, "lp__"), droppars = NULL, rhat = T) %>%
   mutate(Trait = trait)) %>%
  bind_rows() %>%
  kable() %>%
  kable_styling()
```

## Posteriors

```{r , fig.cap="Model parameters posterior.", fig.width=12}
cowplot::plot_grid(plotlist = lapply(traits, function(trait)
  mcmc_intervals(as.array(fits), pars = pars)),
  labels = names(data), nrow = 2)
```

## Chains

```{r , fig.cap="Markov chains trace plot after warmup for intermediate data.", fig.width=12}
mcmc_trace(as.array(fits$invSLA), pars = c(pars, "lp__"),
             facet_args = list(labeller = label_parsed))
```

## Pairs

```{r , fig.cap="Markov chains pairs plot after warmup  for intermediate data."}
mcmc_pairs(as.array(fits$invSLA), pars = pars)
```

## Obs
Do not converge because of sigma.


# Model with random nested effect on species and complex

## Code
```{stan output.var="Model",echo=T, eval=F}
data {
  int<lower=1> N ; // # obs
  int<lower=1> S ; // # species
  int<lower=1> C ; // # complex
  vector[N] Trait ; // Phenotype continuous descriptor
  vector[N] DBH ; // Topographic Wetness Index
  int<lower=1, upper=S> species[N] ; // species index
  int<lower=1, upper=C> speciesincomplex[S] ; // species index wihtin complex
  int<lower=1, upper=C> complex[N] ; // species index
}
parameters {
  vector<lower=0>[S] alpha_s ; // Abiotic intercept for species
  vector<lower=0> [C] alpha_c ; // Abiotic intercept for complexes
  vector<lower=0> [S] betaDBH_s ; // Abiotic slope for species
  vector<lower=0> [C] betaDBH_c ; // Abiotic slope for complexes
  real<lower=0> sigmaIntercept ; // Abiotic intercept variance for species
  real<lower=0> sigmaDBH ; // Abiotic slope variance for species
  real<lower=0> sigma ; // Abiotic variance
}
// transformed parameters {
  // vector<lower=0> [S] betaDBH_s ; // Abiotic slope for species
//  vector<lower=0> [C] betaDBH_c ; // Abiotic slope for complexes
 // betaDBH_s = exp(-0.5*betaDBHP_s) ;
//  betaDBH_c = exp(-0.5*betaDBHP_c) ;
//}
model {
  alpha_s ~ normal(alpha_c[speciesincomplex], sigmaIntercept) ;
  betaDBH_s ~ normal(betaDBH_c[speciesincomplex], sigmaDBH) ;
  Trait ~ normal((alpha_s[species].*DBH) ./ (betaDBH_s[species]+DBH), sigma) ; // Likelihood
}
generated quantities {
  matrix[N,C] Trait_pred ;
  for(c in 1:C)
    Trait_pred[,c] = alpha_c[c] + betaDBH_c[c] *DBH ; // Predictions
}
```

## Summary

```{r }
# fits <- lapply(mdata, function(x) sampling(Model, chains = 2, data = x))
# names(fits) <- traits
# save(fits, file = "./functional_save/OntoM3.Rdata")
load("./functional_save/OntoM3.Rdata")


lapply(as.list(traits), function(trait)
  broom::tidyMCMC(fits[[trait]], pars = c(pars, "lp__"), droppars = NULL, rhat = T) %>%
   mutate(Trait = trait)) %>%
  bind_rows() %>%
  kable() %>%
  kable_styling()
```
## Posteriors

```{r , fig.cap="Model parameters posterior."}
cowplot::plot_grid(plotlist = lapply(traits, function(trait)
  mcmc_intervals(as.array(fits[[trait]]), regex_pars = pars)),
  labels = names(data), nrow = 2)
```

## Chains

```{r , fig.cap="Markov chains trace plot after warmup for intermediate data."}
mcmc_trace(as.array(fits$invLA), regex_pars = c(pars, "lp__"),
             facet_args = list(labeller = label_parsed))
```

## Pairs

```{r , fig.cap="Markov chains pairs plot after warmup  for intermediate data."}
mcmc_pairs(as.array(fits$CC), regex_pars = pars)
```

## Predictions

```{r , fig.cap="Predictions.", fig.width=12, fig.height=12}
lapply(as.list(names(mdata)), function(type)
  cbind(type = type, 
        trait = as.numeric(scale(Individuals[!is.na(unlist(Individuals[,type])),type],center=F)),
        DBH = as.numeric(scale(Individuals[!is.na(unlist(Individuals[,type])),"DBH"],center=F)),
        Individuals[!is.na(unlist(Individuals[,type])),],
        muEschweilera = apply(as.matrix(fits[[type]], 
                                        pars = paste0("Trait_pred[",
                                                      1:mdata[[type]]$N,",1]")), 
                              2, mean),
        muSymphonia = apply(as.matrix(fits[[type]], 
                                      pars = paste0("Trait_pred[",
                                                    1:mdata[[type]]$N,",2]")), 
                            2, mean),
        muEschweilera5 = apply(as.matrix(fits[[type]], 
                                         pars = paste0("Trait_pred[",
                                                       1:mdata[[type]]$N,",1]")), 
                               2, quantile, probs = 0.05),
        muSymphonia5 = apply(as.matrix(fits[[type]], 
                                       pars = paste0("Trait_pred[",
                                                      1:mdata[[type]]$N,",2]")), 
                             2, quantile, probs = 0.05),
        muEschweilera95 = apply(as.matrix(fits[[type]], 
                                          pars = paste0("Trait_pred[",
                                                      1:mdata[[type]]$N,",1]")), 
                                2, quantile, probs = 0.95),
        muSymphonia95 = apply(as.matrix(fits[[type]], 
                                        pars = paste0("Trait_pred[",
                                                      1:mdata[[type]]$N,",2]")), 
                              2, quantile, probs = 0.95)
  )) %>% 
  bind_rows() %>% 
  ggplot(aes(x = DBH)) +
  geom_point(aes(y = trait, col = as.factor(Genus))) +
  geom_line(aes(y = muEschweilera, col = "Eschweilera")) +
  geom_line(aes(y = muEschweilera, col = "Symphonia")) +
  geom_ribbon(aes(ymin = muEschweilera5, ymax = muEschweilera95,
                  col = "Eschweilera"), alpha = 0.2) +
    geom_ribbon(aes(ymin = muSymphonia5, ymax = muSymphonia95,
                  col = "Symphonia"), alpha = 0.2) +
  facet_wrap(~ type, scales = "free", nrow = 3)
```
